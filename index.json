[{"content":"kindleèµ„æº å¹¸ç¦çš„å‘³é“Â https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ å…¬ä¼—å·SobookÂ https://sobooks.cc/ å°ä¹¦å±‹ www.mebook.cc \\ å­åˆä¹¦ç®€Â https://5kindle.com/ å·²åºŸå¼ƒ http://shuxiangjia.cn/?cate=2 ç›®å½• SooHubÂ 2022.09.13å·²æ‰“ä¸å¼€ https://www.soohub.com/ finelybook http://finelybook.com/ å¥½è¯» http://haodoo.net/ é•¿åŸä¹‹å¤– LibraryÂ GenesisÂ mobi\u0026amp;PDF http://gen.lib.rus.ec/ https://libgen.li/ https://libgen.gs/ https://sci-hub.41610.org/library-genesis https://libgen.rs/search.php?\u0026amp;req=KVM\u0026amp;phrase=1\u0026amp;view=simple\u0026amp;column=def\u0026amp;sort=year\u0026amp;sortmode=DESC https://libgen.rs/ zlibrary PDF https://zh.u1lib.org/ https://en.ru1lib.org/ FreeTechBooksÂ è®¡ç®—æœºç§‘å­¦ç±» http://www.freetechbooks.com/ https://www.freetechbooks.com/ å¤ç™»å®è®¡åˆ’ http://www.gutenberg.org/ PlanetÂ eBookÂ å›½å†…å¯è®¿é—® https://www.planetebook.com/ å¸ƒå…‹ä¹¦å±‹ https://iao.su/3064/comment-page-1 https://www.bukebook.cn yuduÂ https://express.yudu.com/ kindle ç¤¾åŒº ä¹¦ä¼´Â https://bookfere.com/post/4.htmlÂ å‚è€ƒé“¾æ¥ï¼š http://www.360doc.com/content/20/0219/14/5008209_893150066.shtml http://www.sohu.com/a/215001801_490529\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/ebookwebsite/","summary":"kindleèµ„æº å¹¸ç¦çš„å‘³é“ https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ å…¬ä¼—å·Sobook https://sobooks.cc/ å°ä¹¦å±‹ www.mebook.cc \\ å­åˆä¹¦ç®€ https://5kindle.com/ å·²åºŸå¼ƒ http://shuxiangjia.cn/?cate=2 ç›®å½• SooHub 2022.09.13å·²æ‰“ä¸å¼€ https://www.soohub.com/ finelybook http://finelybook.com/ å¥½è¯» http://haodoo.net/ é•¿åŸä¹‹å¤– Library Genesis mobi\u0026amp;PDF","title":"ç”µå­ä¹¦ç½‘ç«™"},{"content":"â€‚æ¯ä¸€ç¯‡éƒ½ä»é“æ­‰å¼€å§‹ï¼Œå› ä¸ºäººæ˜¯è¦ä¸ºè‡ªå·±æ‰€è¯´çš„ï¼Œæ‰€åšçš„æ‰¿æ‹…è´£ä»»ï¼Œæ— è®ºèƒ½ä¸èƒ½è·å¾—ä½ çš„åŸè°…ï¼Œè¿™äº›éƒ½æ˜¯æˆ‘éœ€è¦æ‰¿æ‹…çš„ï¼Œå°±åƒä½ è¯´è¿‡çš„ï¼Œä¸–äº‹å°±è¿™ä¹ˆè‰°éš¾å§ã€‚é™Œç”Ÿäººï¼Œä»ç›¸è¯†ç›¸çŸ¥å¾ˆéš¾äº†ï¼Œè€Œæˆ‘åˆæŠŠæˆ‘ä»¬ä¹‹é—´å¢åŠ å›°éš¾ å¾ˆæƒ³çŸ¥é“ä½ é‡åˆ°äº†ä»€ä¹ˆé—®é¢˜ï¼Œä¸è¿‡ä½ åº”è¯¥ä¸ä¼šè¯´çš„ï¼Œé‚£ä¹ˆåŸºäºæˆ‘çš„çŒœæµ‹æ¥è¯´è¯´ï¼Œåº”è¯¥æ˜¯æä¸å‡†ç¡®çš„ï¼Œå› ä¸ºæ²¡æœ‰å¾ˆå¤šä¿¡æ¯ã€‚è¦æ˜¯æœ‰ä»€ä¹ˆå†’çŠ¯å’Œé”™è¯¯è¯·è§è°…ã€‚ ç¬¬ä¸€ç‚¹ï¼Œå…¶å®æˆ‘æ„Ÿè§‰åˆ°ä½ æœ€è¿‘å¯èƒ½åœ¨æ”’é’±ï¼Œåˆ¤æ–­ä¾æ®æ˜¯ä½ ä¸æ‰“ç®—æ¢æ‰‹æœºå’Œä¸€äº›èŠå¤©ç»†èŠ‚ã€‚è®°å¾—10æœˆ1å·åœ¨åœ°å›ä¹°é…¸å¥¶ï¼Œé‚£æ—¶å€™åº”è¯¥æ˜¯ç”±ä½ æ¥ä»˜çš„ï¼Œè¿™æ ·æ˜¯å¾ˆåˆé€‚çš„ã€‚é‚£æ—¶æˆ‘æƒ³åˆ°äº†ä¸€äº›äº‹ï¼Œæ‰€ä»¥æˆ‘å°±æŠ¢ç€ä»˜äº†ï¼Œä½†æ˜¯å¤„ç†çš„å¾ˆå°´å°¬ï¼Œä½ ä¹Ÿåº”è¯¥æ„Ÿå—åˆ°äº†ï¼Œä»é‚£ä¸€åˆ»å¼€å§‹æˆ‘å°±ä¸å¤ªè‡ªç„¶äº†ã€‚ä¹Ÿè¶Šæ¥è¶Šä¸ä¼šå¤„ç†ï¼Œè®©ä½ æ„Ÿè§‰ä¸èˆ’æœäº†ã€‚æ€»ä¹‹æ˜¯æˆ‘æŠ±ç€æ„å›¾ç„¶åä¸ä¼šå¤„ç†äº†ã€‚ ç¬¬äºŒç‚¹ï¼Œä½ é‡åˆ°çš„é—®é¢˜æ˜¯å’Œæˆ¿è´·ä»€ä¹ˆæœ‰å…³ç³»å—ï¼Ÿå› ä¸ºä½ å…¶å®æåˆ°è¿‡ä¸¤æ¬¡å…³äºæˆ¿è´·ï¼Œåˆ©ç‡çš„è¯é¢˜ï¼Œä½†æˆ‘éƒ½æ²¡ç»§ç»­ï¼Œå…³äºåˆ©ç‡è¿™ä¸ªåœ¨å‡ å‘¨ä¹‹å‰å·²ç»æ”¾é£å‡ºæ¥äº†ï¼Œä¹Ÿçœ‹åˆ°äº†ä¸€äº›æŠ¥å‘Šå’Œæ•°æ®ï¼Œæ€»ä¹‹ä¸æ˜¯å¾ˆä¹è§‚ï¼Œæ‰€ä»¥æˆ‘ä¸å¤ªæƒ³èŠï¼Œå› ä¸ºå¯¹è¿™ä¸ªæ˜¯æ¯”è¾ƒæ‚²è§‚çš„ï¼Œå¸‚åœºè¡¨ç°æ•°æ®ä¸æ˜¯å¾ˆå¥½ï¼Œå¯¹äºä¸ªä½“ä¸ç¡®å®šæ€§å¢å¤§ã€‚è¿˜æœ‰ä¸€ç‚¹æ˜¯è‡ªå‘ï¼Œå°±æ˜¯æˆ‘ç°åœ¨å¯èƒ½ä¸èƒ½ç‹¬ç«‹è§£å†³ï¼Œæˆ‘ä¸èƒ½è¦æ±‚ä¸Šä¸€ä»£ä»€ä¹ˆï¼Œåªèƒ½è‡ªå·±åˆ›é€ æœªæ¥ï¼Œä¹Ÿå¸Œæœ›æœ‰ä¸€ä¸ªä¸€åŒå¥‹æ–—ã€‚è¯´å›é—®é¢˜ï¼Œä½ å¦‚æœéœ€è¦ï¼Œæˆ‘å¯ä»¥å‡ºä¸€ä»½åŠ›ï¼Œæˆ‘ä¹Ÿä¸æ˜¯æ¯«æ— æ ¹æ®çš„ä¿¡ä»»ï¼Œæ˜¯åŸºäºæˆ‘å¯¹ä½ çš„åˆ¤æ–­ï¼Œä½ è‡³å°‘æ˜¯æœ‰å¥‘çº¦ç²¾ç¥çš„ï¼Œå¹¶ä¸”ç‹¬ç«‹çš„å€ºåŠ¡å…³ç³»å¹¶ä¸å½±å“ä½ å¯¹æˆ‘çš„è¯„ä»·ï¼Œå³ä½¿æœ€ç»ˆä½ è®¤ä¸ºæˆ‘ä»¬ä¸é€‚åˆä¹Ÿå¹¶ä¸å½±å“ä»€ä¹ˆã€‚ ç¬¬ä¸‰ç‚¹ï¼Œæˆ–è€…ä½ é‡åˆ°ä»€ä¹ˆçªç„¶çš„å˜æ•…äº†å—ï¼Ÿæˆ‘çŸ¥é“ä½ æ˜¯ä¸€ä¸ªå¾ˆç‹¬ç«‹çš„å¥³å­©ï¼Œæœ‰è‡ªå·±çš„èƒ½åŠ›å¤„ç†ï¼Œå¯æ˜¯ç”Ÿæ´»è¦æ˜¯æœ‰ä¸€ä¸ªå¯ä»¥åˆ†æ‹…çš„äººå¾ˆå¤šå›°éš¾å°±ä¸ä¼šé‚£ä¹ˆæ— åŠ©ï¼Œå³ä½¿èƒ½å¤Ÿå’Œä½ åˆ†æ‹…çš„äººä¸æ˜¯æˆ‘ï¼Œä½ ä¹Ÿå¯ä»¥å°è¯•ä¸€ä¸‹ã€‚ä¸€ä¸ªäººå»ç•™å­¦ï¼Œä½ éƒ½èƒ½åº”ä»˜çš„æ¥ï¼Œç°åœ¨é‡åˆ°çš„é—®é¢˜ä½ ä¹Ÿä¸€å®šèƒ½å¤„ç†å¥½ã€‚ä»ä½ çš„æƒ³æ³•ï¼Œæ€åº¦ä¸­èƒ½å¤Ÿçœ‹åˆ°ä½ çš„åšæ¯…ã€‚ å¯èƒ½å†™ä¸‹è¿™äº›éƒ½æ¯«æ— æ„ä¹‰ï¼Œå¯èƒ½æ›´å¤šçš„æ˜¯ç»™è‡ªå·±ä¸€ä¸ªæ•‘èµï¼ŒåŸè°…ä¸€ä¸ªé™Œç”Ÿäººæ˜¯å¾ˆéš¾çš„ï¼Œç¬¬ä¸€å°è±¡å¾ˆé‡è¦ï¼Œè€Œç ´åè¿™ä¸ªå°è±¡ä¹‹åå°±å¾ˆéš¾ä¿®å¤äº†ï¼Œå¹¶ä¸å¥¢æ±‚ä½ å†æ¬¡è®¤å¯æˆ‘ï¼Œé€€å›åˆ°ä¸æ›¾ç›¸è§ä¹Ÿæ˜¯ä¸€ç§å¥å·ã€‚å½“ç„¶æˆ‘éœ€è¦ä¸ºè‡ªå·±æ‰€åšçš„æ‰€è¯´çš„ä»˜å‡ºä»£ä»·ï¼Œå¯èƒ½ä¹Ÿéœ€è¦ä¸€ä¸ªæ”¯ç‚¹æ¥åˆ†æ‹…å‡ºæˆ‘è‡ªå·±çš„é”™è¯¯ï¼Œåœ¨æ²¡æœ‰å¾—åˆ°åˆ«äººå…è®¸çš„æƒ…å†µä¸‹å°†åˆ«äººæ”¾è¿›å¿ƒé‡Œæ˜¯ä¸ç¤¼è²Œçš„ï¼Œå¯èƒ½åœ¨æ— æ³•è·å¾—åŸè°…çš„æ—¶å€™ï¼Œåªèƒ½è‡ªå·±æ…¢æ…¢ç§»å‡ºï¼Œè¿˜å¥½æ²¡æœ‰å¾ˆæ·±ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªæˆé•¿ç‚¹å§ï¼Œå¯¹æœªæ¥æ˜¯æœ‰å¸®åŠ©çš„ã€‚ ä¸‹ä¸€ç¯‡å†™å†™æ›¾ç»çš„æ„Ÿæƒ…ï¼Œè¿‡å»ï¼Œç°åœ¨ï¼Œæœªæ¥ï¼Ÿ Taylor Swiftå‘å¸ƒäº†æ–°ä¸“è¾‘ï¼Œé‡Œé¢æœ‰ä¸€é¦–å¾ˆå–œæ¬¢ã€ŠMaroonã€‹ï¼Œæš‚æ—¶æ‰¾ä¸åˆ°èµ„æºï¼Œè‡ªå·±æœä¸€ä¸‹å§ updateï¼Œæœ€åæé†’ä¸€ä¸ªäº‹æƒ…ï¼Œä¸ªäººé¢„æµ‹ï¼Œä¸ä¿è¯å‡†ç¡®ï¼Œå¼€å®Œä¼šä¹‹åå¦‚æœæ²¡æœ‰ä»€ä¹ˆäº‹æƒ…å‘ç”Ÿï¼Œå£ç½©ç›¸å…³æ”¿ç­–ä¼šåœ¨å‡ ä¸ªæœˆå†…æ”¾æ¾ï¼Œä¸çŸ¥é“ä½ æ˜¯ä»€ä¹ˆæ€åº¦ï¼Œä¸ªäººæ€åº¦æ˜¯å°Šé‡ç§‘å­¦ï¼Œæ‰€æœ‰äººéƒ½èººå¹³ï¼Œè°ä¹Ÿæ²¡åŠæ³•æ”¹å˜ï¼Œå¯¹äºæˆ‘ä»¬ä¸ªä½“è€Œè¨€ï¼Œä¸è¦ææ…Œï¼Œå¯ä»¥å‡†å¤‡ä¸€ç‚¹æŠ—ç—…æ¯’ä¹‹ç±»çš„è¯ç‰©ï¼Œå¤§éƒ¨åˆ†éƒ½æ˜¯æ²¡äº‹ï¼Œæ¯å¹´éƒ½æœ‰å› ä¸ºæ™®é€šæµæ„ŸæŒºä¸è¿‡å»çš„ï¼Œç°åœ¨è¿™ä¸ªå’Œæµæ„Ÿæ²¡æœ‰å¤ªå¤§åŒºåˆ«ã€‚ä¸æŠ˜è…¾æ˜¯æœ€å¥½çš„åº”å¯¹æªæ–½ï¼Œäºä¸ªä½“è€Œè¨€ä¹Ÿä¸€æ ·ã€‚å¦‚æœä½ æ¯”è¾ƒæ”¯æŒï¼Œé‚£å°±å½“å•°å—¦äº†ï¼Œè¯·å¿½ç•¥ã€‚ ","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E5%88%86%E6%8B%85/","summary":"æ¯ä¸€ç¯‡éƒ½ä»é“æ­‰å¼€å§‹ï¼Œå› ä¸ºäººæ˜¯è¦ä¸ºè‡ªå·±æ‰€è¯´çš„ï¼Œæ‰€åšçš„æ‰¿æ‹…è´£ä»»ï¼Œæ— è®ºèƒ½ä¸èƒ½è·å¾—ä½ çš„åŸè°…ï¼Œè¿™äº›éƒ½æ˜¯æˆ‘éœ€è¦æ‰¿æ‹…çš„ï¼Œå°±åƒä½ è¯´è¿‡çš„ï¼Œä¸–äº‹å°±è¿™ä¹ˆè‰°éš¾å§ã€‚é™Œ","title":"åˆ†æ‹…"},{"content":" è¯´æ˜ï¼šæ’ä»¶åŸºäºC/C++ Project Generatorï¼ŒåŸå§‹é¡¹ç›®æœªæ›´æ–°ï¼Œè”ç³»åˆ°ä½œè€…æ²Ÿé€šæ˜¯å¦åˆå…¥\næœ¬é¡¹ç›®åœ°å€: https://github.com/zhuangll/vscode_c_project_config\nå®‰è£… åœ¨vscodeä¸­å®‰è£…C/C++ Project Generatoræ’ä»¶ \\ ä¸‹è½½ä»£ç ï¼Œå°†ä»£ç æ›¿æ¢åˆ°C/C++ Project Generatoræ’ä»¶æ‰€åœ¨ç›®å½•ï¼Œwindowsç¯å¢ƒvscodeæ’ä»¶ç›®å½•,å°†åŠŸèƒ½ä»£ç å¤åˆ¶æ›¿æ¢å¦‚ä¸‹ç›®å½•ä¸­ C:\\Users\\\u0026lt;ç”¨æˆ·å\u0026gt;\\.vscode\\extensions\\danielpinto8zz6.c-cpp-project-generator-1.2.4 mingwå®‰è£…ï¼Œé€‰æ‹©å¦‚ä¸‹é“¾æ¥ä¸‹è½½ä¸€ä¸ªå³å¯ï¼Œæ·»åŠ åˆ°ç¯å¢ƒå˜é‡pathä¸­ å„ç‰ˆæœ¬gcc mingw clang https://winlibs.com/ https://github.com/brechtsanders/winlibs_mingw MinGW-w64 https://www.mingw-w64.org/changelog/ ä½¿ç”¨æ–¹æ³• wingowsç¯å¢ƒéœ€è¦å®‰è£…mingwï¼Œå¹¶æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ linuxç¯å¢ƒé€‚é…ä¸­\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/vscode_c_project_config/","summary":"è¯´æ˜ï¼šæ’ä»¶åŸºäºC/C++ Project Generatorï¼ŒåŸå§‹é¡¹ç›®æœªæ›´æ–°ï¼Œè”ç³»åˆ°ä½œè€…æ²Ÿé€šæ˜¯å¦åˆå…¥ æœ¬é¡¹ç›®åœ°å€: https://github.com/zhuangll/vscode_c_project_config å®‰è£… åœ¨vscodeä¸­å®‰è£…C/C++ Project Gen","title":"vscode c/c++ä¸€é”®åˆ›å»ºå·¥ç¨‹æ’ä»¶"},{"content":"â€‚çœŸçš„ä¸ºé‚£å¤©æ™šä¸Šæ‰€è¯´çš„è¯æ— æ¯”åæ‚”ï¼Œ\u0026ldquo;ç†æ€§ä¸Šè¿½æ±‚å…‹åˆ¶ä¸å¹³é™ï¼Œæ„Ÿæ€§ä¸Šè¢«æ„Ÿæƒ…æ‰€æ·¹æ²¡\u0026quot;å½¢æˆäº†æƒ…æ„Ÿçš„å¯¹ç«‹é¢ã€‚ä½ å¯èƒ½æŠŠæˆ‘å½’ç±»ä¸ºä½ åŒå­¦åœ¨å¤§å­¦é‡Œé‡åˆ°çš„é‚£ä¸ªç”·ç”Ÿäº†ï¼Œçº ç¼ å«‰å¦’ç‹­éš˜è‡ªç§ï¼Œæ€»ä¹‹ä¸€å®šæ˜¯ä¸€ä¸ªä¸åˆæ ¼çš„ã€‚æ‰€ä»¥æˆ‘æ‰€å†™ä¸‹çš„æ¯ä¸€é¡µéƒ½æ˜¯åœ¨é˜è¿°æˆ‘æ˜¯ä¸€ä¸ªä»€ä¹ˆæ ·çš„ï¼Œè¿˜å€¼ä¸å€¼å¾—ä½ åŸè°…ï¼Œå½“ç„¶æœ€é‡è¦éƒ½æ˜¯ä½ çš„æ„Ÿå—æ¥å†³å®šçš„ã€‚ é¦–å…ˆæ˜¯å…³äºè‡ªç§çš„é—®é¢˜ï¼Œæˆ‘ä¸€ç›´çš„å¤„äº‹åŸåˆ™æ˜¯å‡¡äº‹éƒ½å¯å•†é‡ï¼Œè€Œä¸”æ˜¯ä¸å–œæ¬¢åšå†³å®šçš„äººï¼Œä½†å–œæ¬¢åšè®¡åˆ’ï¼Œä½ åº”è¯¥æ˜¯ä¸€ä¸ªå–œæ¬¢å†³æ–­çš„æ€§æ ¼ï¼Œå°±åƒå›½åº†å‡ºæ¸¸è®¡åˆ’ä¸€æ ·ï¼Œåšå‡ºä¸æ­¢ä¸€ä¸ªè®¡åˆ’å¯é€‰ï¼ŒåŒæ—¶æ›´å¸Œæœ›ä½ æœ‰å…¶ä»–çš„è§„åˆ’ã€‚é‚£å¤©æ™šä¸Šå°±æ˜¯å¤ªå¸Œæœ›çœ‹åˆ°ç»“æœäº†ï¼Œå¤ªå¸Œæœ›å¯ä»¥èµ°è¿›ä½ çš„ç”Ÿæ´»äº†ã€‚å½“ç„¶è¯´å’Œå†™æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œè€Œåšæ‰æ˜¯æœ€é‡è¦çš„ï¼Œå¦‚æœæœªæ¥è¿˜æœ‰å¯èƒ½ä¼šè®©ä½ æ„Ÿå—åˆ°çš„ï¼Œå› ä¸ºæ›¾ç»å°±æ˜¯è¿™æ ·çš„ã€‚å¦ä¸€ç‚¹é¢æ˜¯å¼‚æ€§å…³ç³»ï¼Œå³ä½¿æ˜¯ç¡®å®šå…³ç³»ä¹Ÿå¯ä»¥æœ‰å¼‚æ€§æœ‹å‹å•Šï¼Œé‚£å¤©ä½ è¯´åˆ°é‚£ä¸ªç”·ç”Ÿæ—¶æˆ‘ç¬¬ä¸€ä¸ªæƒ³åˆ°çš„å°±æ˜¯è¿™ä¸ªè§‚ç‚¹ï¼Œåªæœ‰å½¼æ­¤å¦è¯šç›¸å¾…ï¼Œå·¥ä½œï¼Œç”Ÿæ´»ä¸å¯èƒ½æ²¡æœ‰å¼‚æ€§æœ‹å‹çš„ï¼Œè¦æ˜¯ç‹­éš˜çš„è¿™ç§é‚£ç”Ÿæ´»ä¸€å®šå¾ˆç´¯äº†ï¼Œæ—¶æ—¶åˆ»åˆ»éœ€è¦æ‹…å¿§ä¸æ€€ç–‘ï¼Œè¿˜æœ‰ä»€ä¹ˆè‡ªç”±å¯è¨€ï¼Œè°ˆåˆ°è‡ªç”±ï¼Œçˆ±æƒ…åº”è¯¥æ˜¯è‡ªç”±è‡ªåœ¨çš„ï¼Œå¦‚æœçˆ±æƒ…æˆäº†çº¦æŸé‚£ä¹ˆå°±æ²¡æœ‰å¿…è¦äº†ï¼Œæˆ‘è¿™æ ·ç†è§£å¯¹å—ï¼Ÿ ç„¶åæ˜¯å…³äºåˆ†å¯¸æ„Ÿï¼Œè¿™ä¸€ç‚¹ä¹Ÿæ²¡æœ‰æŠŠæ¡å¥½ï¼Œå› ä¸ºä½ çš„æ„Ÿå—åº”è¯¥æ˜¯ç¬¬ä¸€ä½çš„ï¼Œå…³äºåœ°é“ç«™çš„é—®é¢˜æ˜¯æˆ‘æ²¡æœ‰é‡è§†ï¼Œè®¤ä¸ºæ˜¯ä¸€ä»¶å¾ˆå°çš„äº‹æƒ…ï¼Œä½†å…¶å®ä¸æ˜¯å¦‚æœå…è®¸æˆ‘é€ä½ äº†ï¼Œå°±æ˜¯ä»£è¡¨äº†ä¸€ç§ä¿¡ä»»ï¼Œæ›´æ˜¯ä¸€ç§æ¥å—ï¼Œå¯æ˜¯ä½ è¿˜æ²¡æœ‰è€ƒè™‘å¥½æˆ‘æ˜¯å¦å€¼å¾—ä¿¡ä»»æ˜¯å¦å€¼å¾—ä»˜å‡ºã€‚è¿™äº›éƒ½æ˜¯æˆ‘é‚£æ—¶å€™æ²¡æœ‰èƒ½å¤Ÿæƒ³åˆ°çš„ï¼Œå…¶å®ä½ å·²ç»æé†’æˆ‘å¾ˆæ˜ç¡®äº†ï¼Œå¯æ˜¯æˆ‘ä½†æ˜¯é™·å…¥åˆ°ä¸è§£ä¸è‡ªç§ä¸­ã€‚å¦‚æœä¼šå†æœ‰æœºä¼šï¼Œä¸€å®šæ˜¯åå€çš„è€å¿ƒï¼Œè®©ä½ æœ‰è¶³å¤Ÿçš„å®‰å…¨æ„Ÿï¼Œä¿¡ä»»æ„Ÿï¼Œå…¶å®é‚£æ—¶å€™åº”è¯¥æ˜¯æ°´åˆ°æ¸ æˆçš„äº‹äº†ï¼Œä¸éœ€è¦æˆ‘åˆ»æ„å»åšä»€ä¹ˆã€‚ æœ€åæ˜¯æˆ‘æ‰€åšçš„ç»™ä½ å¸¦æ¥çš„æ„Ÿå—ï¼Œéƒ½æ˜¯æˆ‘çš„è¡¨è¾¾æ–¹å¼çš„é—®é¢˜ï¼Œæœ€æƒ³è¡¨è¾¾çš„æ˜¯å¯ä»¥ä¸ºä½ åšå¾ˆå¤šå¾ˆå¤šï¼Œä½†è¿™äº›ä¸åº”è¯¥æ˜¯å¯¹ä½ é€ æˆçš„ä¸€ç§è´Ÿæ‹…ï¼Œè€Œåº”è¯¥æ˜¯ä¸€ç§è‡ªçƒ­è€Œç„¶çš„æ„Ÿå—å³å¯ã€‚ è¿™æ˜¯å…³äºæ„Ÿæƒ…çš„æˆé•¿å—ï¼Ÿ çŸ¥é“æˆ‘ä¸ºä»€ä¹ˆä¼šè¿™ä¹ˆå¿«è®¤å®šä½ å—ï¼Ÿä¸ºä»€ä¹ˆæˆ‘è¿™ä¹ˆçƒ­æƒ…ï¼Ÿåœ¨ä½ èº«ä¸Šçœ‹åˆ°å¾ˆå¤šä¸œè¥¿ï¼Œå†…å¿ƒåšå®šï¼Œç”Ÿæ´»æ°”æ¯ï¼Œè‡ªåœ¨ï¼Œä½ å†…å¿ƒæ·±å¤„åº”è¯¥è¿˜æœ‰æ›´å¤šï¼Œå¾ˆå¤šå€¼å¾—å­¦ä¹ çš„ï¼ŒçŒ›ç„¶å‘ç°è¿™äº›éƒ½æ˜¯å‘å¾€å’Œè¿½æ±‚çš„ã€‚æœ€ä»¤äººå‘å¾€çš„æ„Ÿæƒ…åº”è¯¥æ˜¯å½¼æ­¤æˆå°±ï¼Œæˆ‘è¿˜åœ¨æ€è€ƒæˆ‘æœ‰ä»€ä¹ˆå€¼å¾—ä½ åŸè°…çš„ï¼Œè¦æ˜¯æ²¡æœ‰çš„è¯ï¼Œåº”è¯¥æ²¡æœ‰ä¸Šé¢æ‰€æœ‰çš„å¦‚æœäº†ã€‚ ä½ çš„æ„Ÿå—æœ€æœ€é‡è¦ï¼Œæˆ‘ä¸åšé¢„æœŸï¼Œä¸çŸ¥é“é‚£å¤©æ™šä¸Šè„‘è¢‹æŠ½å“ªæ ¹ç­‹ä»€ä¹ˆé¢„æœŸï¼Œç®€ç›´æ¯«æ— æ„ä¹‰ï¼Œæˆ‘ç°åœ¨æ‰€åšçš„ä¸¤ç‚¹ï¼Œç¬¬ä¸€ï¼Œå–å¾—ä½ çš„åŸè°…ï¼Œç¬¬äºŒï¼Œç”»ä¸€ä¸ªå¥å·ï¼Œè¿™ä¸ªå¥å·ä¸æ˜¯é‡æ–°å¼€å§‹è€Œæ˜¯ä¸€ä¸ªå¿ƒå®‰ï¼Œè‡³å°‘ä¸è¦æŠŠæˆ‘å½’ç±»åˆ°é‚£ä¸ªç”·ç”Ÿã€‚ æ›´æ–°åŸåˆ™ï¼šé™é»˜æ›´æ–°ï¼Œä¸åœ¨é€šçŸ¥ï¼Œä¹Ÿè®¸è¿˜ä¼šåŠ ä½ ï¼Œä¸è¿‡ä¸ä¼šå¾ˆé¢‘ç¹ï¼Œä¸è¦æœ‰ä»€ä¹ˆå‹åŠ›ï¼Œä¹Ÿè®¸ä½ ä»æ²¡çœ‹è¿‡ï¼Œä½†è¿™å¹¶ä¸å½±å“æˆ‘ç‹¬è‡ªèµ°è¿‡è¿™æ®µç»å†ï¼Œä¹Ÿä¸åº”è¯¥å½±å“ä½ æ­¤åˆ»çš„ç»å†ã€‚å†…åœ¨å®åŠ›å’Œæ„ŸçŸ¥åŠ›åŠ›ï¼Œè€Œä¸æ˜¯è¡¨ç°å½¢å¼ã€‚ æœ€é‡è¦ä¸€ç‚¹ï¼Œå¦‚æœä½ éœ€è¦æˆ‘éšæ—¶å‡†å¤‡å¥½ã€‚ ","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E7%8B%AC%E7%99%BD/","summary":"çœŸçš„ä¸ºé‚£å¤©æ™šä¸Šæ‰€è¯´çš„è¯æ— æ¯”åæ‚”ï¼Œ\u0026ldquo;ç†æ€§ä¸Šè¿½æ±‚å…‹åˆ¶ä¸å¹³é™ï¼Œæ„Ÿæ€§ä¸Šè¢«æ„Ÿæƒ…æ‰€æ·¹æ²¡\u0026quot;å½¢æˆäº†æƒ…æ„Ÿçš„å¯¹ç«‹é¢ã€‚ä½ å¯èƒ½æŠŠæˆ‘å½’ç±»ä¸ºä½ åŒå­¦","title":"ç‹¬ç™½"},{"content":"\rä¸€ä¸ªåˆåç‚¹ç‡ƒäº†ä¸€é¢—å¿ƒ å²æœˆä¸ä¼šæŠ¹å»æˆ‘çš„è®°å¿†é‡Œä½ æ‰€ç»™çš„é˜³å…‰ å´æ‚„æ‚„çš„ä½¿æˆ‘ä¸åŒ ä¸€ä¸ªå¥³å­©åœ¨æœ‰å¿ƒäººçš„å¿ƒä¸­ æ°¸è¿œä¸ä¼šé—å¿˜ æƒ³åˆ°è¿™äº› ååˆ†çŠ¹è±« ç”Ÿæ´»å¤ªè„†å¤ªè–„ ç”šè‡³ä¸æ¯”ä¸€æ ªèŠ±ç»å¾—ä½é£é›¨å¹´å å€¾å¿ƒè‡ªç„¶çš„çœ¼å•Š äººç”Ÿ çƒ­æƒ…çš„å¯ç åŒä¸€äººäº‹ä¸Š ç¬¬äºŒæ¬¡çš„å‡‘å·§æ˜¯ä¸ä¼šæœ‰çš„ æˆ‘å¹³ç”Ÿåªè§è¿‡ä¸€æ¬¡å¤©è“ ç»™è‡ªå·±å®½æ…° è¯´\nè¡Œè¿‡å¾ˆå¤šè·¯ è§è¿‡å¤šæ¬¡æµ· çœ‹è¿‡è®¸å¤šå¤©ç©º å´åªæ‹ä¸€ä¸ªæœ€å¥½å¿ƒçµçš„äººã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;2022.10.03\n","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E8%87%B4%E5%A8%9C/","summary":"ä¸€ä¸ªåˆåç‚¹ç‡ƒäº†ä¸€é¢—å¿ƒ å²æœˆä¸ä¼šæŠ¹å»æˆ‘çš„è®°å¿†é‡Œä½ æ‰€ç»™çš„é˜³å…‰ å´æ‚„æ‚„çš„ä½¿æˆ‘ä¸åŒ ä¸€ä¸ªå¥³å­©åœ¨æœ‰å¿ƒäººçš„å¿ƒä¸­ æ°¸è¿œä¸ä¼šé—å¿˜ æƒ³åˆ°è¿™äº› ååˆ†çŠ¹è±« ç”Ÿæ´»å¤ªè„†å¤ªè–„ ç”šè‡³ä¸æ¯”","title":"è‡´å¨œ"},{"content":"â€‚ğŸ’“ è¿™ä¸ªç½‘ç«™æ˜¯ä¸ºä½ å‡†å¤‡çš„ç¤¼ç‰©ï¼Œæ²¡æœ‰è®¡åˆ’æ·»åŠ æ–‡å­—ï¼Œä¸ºäº†è·å¾—ä½ çš„åŸè°…æƒ³åœ¨æ¯ä¸€é¡µå†™ä¸Šæ–‡å­—ï¼Œç”±äºæˆ‘ä¸æ˜¯åšå‰ç«¯çš„æ°´å¹³æœ‰é™ï¼Œæœ€è¿‘å‘ç°å¾ˆå¤šbugï¼Œç‰¹åˆ«æ˜¯ä¸åŒå±å¹•é€‚åº”é—®é¢˜ï¼Œåœ¨å¤§ä¸€ç‚¹çš„å±å¹•æ˜¾ç¤ºæ•ˆæœå¾ˆå¥½ï¼Œç¬”è®°æœ¬å±å¹•æ¯”è¾ƒå°çš„è¯æ˜¾ç¤ºæœ‰é—®é¢˜ï¼Œå°è¯•å¾ˆå¤šæ–¹æ³•æš‚æ—¶æ²¡èƒ½ä¿®å¤ï¼Œæ‰€ä»¥å°±æŠŠæ–‡å­—å†…å®¹æ”¾åˆ°æˆ‘çš„ä¸ªäººåšå®¢ï¼Œæ·»åŠ ä¸€ä¸ªå†™ç»™å¨œçš„ä¸“æ ï¼Œç‚¹å‡»æ¯ä¸€é¡µçš„å›¾ç‰‡è·³åˆ°è¿™é‡Œå¯¹åº”çš„æ–‡ç« ã€‚å¦å¤–çš„ç½‘ç«™ä¼šæ·»ä¸€äº›å¥½ç©çš„å°åŠŸèƒ½ï¼Œç®€å•çš„å†™å‡ å¥è¯ã€‚ ä»ä¸ºä»€ä¹ˆåŠ ä½ å¼€å§‹å§ï¼Œå› ä¸ºè¥„é˜³ï¼Œä»å°å°±çŸ¥é“è¿™ä¸ªåŸå¸‚ï¼Œè€Œä¸”åœ¨å°æ—¶å€™å†…å¿ƒæœ‰ä¸€ç§å‘å¾€ï¼ŒåŒ…å«äº†ç¥–è¾ˆçš„æ•¬ä»°ã€‚ä½ æ˜¯ä¸€å¹´å¤šæ¥ç¬¬ä¸€æ¬¡ä¸»åŠ¨æ¥è§¦çš„å¥³å­©ï¼Œå› ä¸ºè¿™ä¸€å¹´å¤šæˆ‘èŠ±å¾ˆå¤§ä¸€éƒ¨åˆ†æ—¶é—´ç”¨æ¥èµ°å‡ºä¸Šä¸€æ®µæ„Ÿæƒ…ï¼Œè¿™å°±æ˜¯ä½ è¯´çš„æˆ‘æ„Ÿæƒ…ä¸ç¨³å®šçš„åŸå› ï¼Œå…³äºè¿‡å»çš„æ„Ÿæƒ…ä¼šä¸“é—¨å†™ä¸€ç¯‡ï¼Œå…¶å®æƒ³æ›´å¤šçš„äº†è§£ä½ çš„è¿‡å»ã€‚ ç½‘ç«™æœ‰ä¸€ä¸ªæ˜¯ä¸€ä¸ªè®¡æ•°å™¨ä¼šè‡ªåŠ¨è®°å½•æˆ‘ä»¬ç›¸è¯†å¤šä¹…äº†ï¼Œåˆ°10æœˆ2å·æ˜¯ç¬¬10å¤©ï¼Œ10å¤©æ—¶é—´æˆ‘ä»¬å±…ç„¶é‚£ä¹ˆç†Ÿæ‚‰äº†ï¼Œå¯¹äºä¸€ä¸ªæ…¢çƒ­çš„äººï¼Œä»æœªå¦‚æ­¤å¿«é€Ÿçš„èµ°è¿‘å…¶ä»–äººã€‚æˆ‘ä»¬èŠäº†å¾ˆå¤šå¾ˆå¤šäº†ï¼Œä½ è¯´çš„å¾ˆå¤šè¯æˆ‘éƒ½è®°å¾—äº†ï¼Œå¾ˆå¤šè¿˜éœ€è¦æœªæ¥æ¥å®ç°ã€‚ä½ æ˜¯ä¸€ä¸ªå¾ˆæœ‰æ™ºæ…§çš„å¥³ç”Ÿï¼Œæ‰10å¤©æ€ä¹ˆå¯èƒ½ä¼šæ¥å—ä¸€ä¸ªäººå‘¢ï¼Œæˆ‘ä¸çŸ¥é“å“ªé‡ŒæŠ½ç­‹äº†ï¼Œå°±åœ¨å‡ºå·®ä¹‹å‰éè¦ä¸€ä¸ªç»“æœï¼Œé‚£ä¸ªæ™šä¸Šä¸€ä¸ªæ™šä¸Šæ²¡æœ‰ç¡ï¼Œç»ˆäºæƒ³æ˜ç™½äº†ï¼Œæ˜¯å› ä¸ºæˆ‘å¤ªæƒ³èµ°è¿›ä½ çš„ç”Ÿæ´»ï¼Œæƒ³å¾—èµ°ç«å…¥é­”ä¸€æ ·ã€‚æ­¤åˆ»æƒ³æƒ³æ‰10å¤©ï¼Œæœªæ¥æ—¥å­è¿˜æœ‰å¾ˆä¹…å¾ˆä¹…å‘¢ï¼Œå³ä½¿å‡ºå·®ä¹Ÿå°±ä¸€ä¸¤ä¸ªæœˆï¼Œæ”¾åœ¨æ—¶é—´çš„é•¿æ²³é‡Œå¤ªçŸ­å¤ªçŸ­äº†ã€‚ çœ‹çœ‹é‚£ä¸ªæ™šä¸Šè‡ªå·±è¯´çš„è¯ï¼ŒçœŸçš„åº”è¯¥æŠ½æˆ‘è‡ªå·±ï¼Œæ€ä¹ˆå†™å‡ºé‚£ä¹ˆè‡ªç§ã€è‡ªæˆ‘çš„è¯ï¼Œå¿ƒä¸­æœ‰é‚£ä¹ˆå¤šå¤šæƒ…æ„Ÿè¦è¡¨è¾¾ï¼Œå´ååå†™äº†é‚£æ ·ä¼¤ä½ å¿ƒçš„è¯ã€‚æˆ‘æ˜¯ä½ ä¹Ÿæ˜¯ä¼šåˆ äº†ï¼Œæ°¸è¿œä¸æƒ³åœ¨è§åˆ°è¿™ä¸ªäººã€‚ä½†è¯·ç›¸ä¿¡æˆ‘ï¼Œæˆ‘æ˜¯ä¸€ä¸ªçŸ¥é”™èƒ½æ”¹çš„ï¼Œå°±åƒæˆ‘ä»¬ä¸€å¼€å§‹é‚£æ ·ä½ è¯´éœ€è¦åˆ†äº«å¼äº¤æµï¼Œè¿™æ˜¯ä½ ç»™æˆ‘çš„ä¸€ä¸ªæˆé•¿å¯è¿ªã€‚è®©ä½ ç›¸ä¿¡ä¸æ˜¯è¯´è¯´å°±è¡Œçš„ï¼Œéœ€è¦çœ‹æ€ä¹ˆåšã€‚å°±å½“è¿™æ˜¯ä¸€æ¬¡å¯¹æˆ‘çš„æƒ©ç½šå§ï¼Œä½ æœŸå¾…ä¸€ä¸ªæˆç†Ÿç¨³é‡çš„äººï¼Œæˆ‘æ˜¯è¿™æ ·çš„æ€§æ ¼å½“ç„¶è¿˜æœ‰å¾ˆå¤šä¸æˆç†Ÿçš„åœ°æ–¹éœ€è¦å®Œå–„ï¼Œè¿™äº›éƒ½ä¸æ˜¯æˆ‘è¯´è¯´ï¼Œè€Œæ˜¯åº”è¯¥ç›¸å¤„åä½ æ¥è¯„ä»·çš„ã€‚ æ¯æ¬¡å’Œä½ èŠå®Œå¤©æˆ‘éƒ½ä¼šæ€è€ƒå“ªé‡Œæœ‰æ²¡æœ‰è¯´çš„ä¸åˆé€‚çš„ï¼Œæ¯”å¦‚å…³äºéšç¤¼é‚£æ¬¡ï¼Œåä¸€æˆ‘é‡åˆ°äº†åŒæ ·çš„äº‹æƒ…ï¼Œå½“æ—¶æˆ‘è¯´çš„å’Œæˆ‘åšçš„å°±å¾ˆä¸ä¸€æ ·ï¼Œæˆ‘è¿˜æ˜¯ä¸»åŠ¨éšäº†ï¼Œå› ä¸ºé‚£æ˜¯å¯¹æ›¾ç»å‹è°Šçš„çºªå¿µã€‚2å·æ™šä¸Šä½ å‘æ¶ˆæ¯çš„æˆ‘çœ‹äº†å¾ˆå¤šå¾ˆå¤šéï¼Œè¯»æ‡‚ä½ å¾ˆå¤šé¡¾è™‘ã€æ„Ÿå—è¿˜æœ‰ç»™æˆ‘çš„çš„æœºä¼šï¼Œå¹³æ—¶åœ¨ç”Ÿæ´»ä¸­æˆ‘æ˜¯å¾ˆç…§é¡¾ä»–äººçš„æ„Ÿå—çš„ï¼Œæœ‹å‹åŒäº‹éƒ½è¿™æ ·è¯„ä»·è¿‡æˆ‘ã€‚ å…³äºä¿¡ä»»ä½ åšçš„å¾ˆå¯¹å¾ˆå¯¹ï¼Œå¥³å­©å­ä¿æŠ¤å¥½è‡ªå·±ï¼Œæˆ‘ä¸ºä»€ä¹ˆæƒ³çŸ¥é“ä½ ç¦»é‚£ä¸ªåœ°é“ç«™è¿‘ï¼Œæ˜¯å› ä¸ºç¬¬ä¸‰ä¸ªç¤¼ç‰©éœ€è¦é€åˆ°ã€‚ä½ çš„è§‚ç‚¹æ˜¯éœ€è¦ç»§ç»­è§‚å¯Ÿè§‚å¯Ÿæˆ‘ï¼Œè¿™æ˜¯åˆæƒ…åˆç†çš„ã€‚æˆ‘éœ€è¦æœ‰è€å¿ƒå»è®©ä½ è§‚å¯Ÿä¸è¯„ä»·ã€‚è€å¿ƒï¼Œä¸€ä¸ªé•¿è·‘å‹é€‰æ‰‹æ˜¯å¾ˆæœ‰è€å¿ƒçš„ã€‚ æˆ‘çŸ¥é“ä½ ä¼šè®¤ä¸ºæˆ‘å†™çš„ä¸Šé¢çš„ä¸œè¥¿å…¨ç¯‡éƒ½æ˜¯è‡ªæˆ‘ï¼Œå¾ˆå¤šéƒ½æ˜¯å›æƒ³ã€æ€è€ƒä½ æ‰€è¯´çš„è¯åæˆ‘æƒ³æˆ‘åº”è¯¥æ€ä¹ˆåšçš„ã€‚ å…³äºæœªæ¥è®¡åˆ’ï¼Œä¸çŸ¥é“èƒ½ä¸èƒ½å†æ¬¡æ‰“åŠ¨ä½ ï¼Œè·å¾—ä½ çš„åŸè°…ï¼Œä½†æˆ‘ä¼šåœ¨ä¸€ä¸ªä¸è®©ä½ åŒçƒ¦çš„è·ç¦»æ¥è¯·æ±‚ä½ çš„è°…è§£,10å¤©å¯¹åº”çš„æœ€å°‘æ˜¯10ä¸ªæœˆå§ï¼Œåº”è¯¥ä¼šæ˜¯æ›´ä¹…å§ã€‚ç½‘ç«™æ¯å‘¨å‘¨æœ«å¿…æ›´ï¼Œä¹Ÿå¯èƒ½ä¼šä¸€å‘¨ä¸¤æ›´ã€‚\n","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E9%81%93%E6%AD%89/","summary":"ğŸ’“ è¿™ä¸ªç½‘ç«™æ˜¯ä¸ºä½ å‡†å¤‡çš„ç¤¼ç‰©ï¼Œæ²¡æœ‰è®¡åˆ’æ·»åŠ æ–‡å­—ï¼Œä¸ºäº†è·å¾—ä½ çš„åŸè°…æƒ³åœ¨æ¯ä¸€é¡µå†™ä¸Šæ–‡å­—ï¼Œç”±äºæˆ‘ä¸æ˜¯åšå‰ç«¯çš„æ°´å¹³æœ‰é™ï¼Œæœ€è¿‘å‘ç°å¾ˆå¤šbugï¼Œç‰¹åˆ«æ˜¯ä¸åŒ","title":"è¯·æ±‚å¨œçš„åŸè°…"},{"content":"ç¼–è¯‘ æ³¨æ„wslä¸­éœ€è¦rootç”¨æˆ·ç¼–è¯‘ https://dynamorio.org/page_building.html cmake \\ -DCMAKE_TOOLCHAIN_FILE=/mnt/e/code/dynamorio/make/toolchain-android=arm64.cmake \\ -DANDROID_TOOLCHAIN=/android_toolchain_using \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio cmake \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio å­¦ä¹ é“¾æ¥ DynamoRIOè¿›é˜¶æŒ‡å— https://blog.csdn.net/oShuangYue12/article/details/109780166 ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/dynamorio/","summary":"\u003ch2 id=\"ç¼–è¯‘\"\u003eç¼–è¯‘\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eæ³¨æ„wslä¸­éœ€è¦rootç”¨æˆ·ç¼–è¯‘\n\u003ca href=\"https://dynamorio.org/page_building.html\"\u003ehttps://dynamorio.org/page_building.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_TOOLCHAIN_FILE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/mnt/e/code/dynamorio/make/toolchain-android\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003earm64.cmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DANDROID_TOOLCHAIN\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/android_toolchain_using \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DDR_COPY_TO_DEVICE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_BUILD_TYPE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eDebug \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_TESTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_SAMPLES\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_CLIENTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e../dynamorio\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DDR_COPY_TO_DEVICE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_BUILD_TYPE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eDebug \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_TESTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_SAMPLES\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_CLIENTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e../dynamorio\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Linuxå†…æ ¸æ·±åº¦è§£æ"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","summary":"","title":"Linuxå†…æ ¸æ·±åº¦è§£æ"},{"content":"gitæ“ä½œ # ä¸‹è½½ä»£ç ï¼Œsshæˆ–https ä¸€ç§æ–¹å¼å‡ºé”™æ¢ç”¨å¦ä¸€ç§ git clone # åˆ›å»ºåˆ†æ”¯ git checkout -b br_master # æäº¤ git status git add . git commit # åˆå¹¶åˆ°å‰ä¸€ä¸ªcommit git commit --amend # æ‹‰å–æ›´æ–°ä»£ç  git pull # æ¨é€ git push # åˆå¹¶å·²pushçš„commit git rebase -i HEAD~n # å¼ºåˆ¶æ›´æ–°è¦†ç›–æœ¬æ¬¡ git fetch --all git reset --hard HEAD git pull # å¼ºåˆ¶æ¨é€ git push -u origin br_master --force # å›åˆä»£ç  git rebase master # å›é€€å·²æäº¤commit git reset --soft \u0026lt;commit-ID\u0026gt; # å¿½ç•¥éƒ¨åˆ†æ–‡ä»¶æäº¤ git add filename # æ”¾å…¥æœ¬åœ°æ ˆ git stash -u -k git commit git push # å¼¹å‡ºæœ¬åœ°æ ˆ git stash pop gité…ç½® git config --global user.name \u0026#34;xxx\u0026#34; git config --global user.email \u0026#34;xxx@163.com\u0026#34; git config --list user.name=xxx user.email=xxx@163.com # ç”Ÿæˆç§˜é’¥ ssh-keygen -t rsa -C \u0026#39;xxx@163.com\u0026#39; # cd ~/.ssh å°† id_rsa.pub æ·»åŠ é“GitHub # æµ‹è¯•é“¾æ¥ ssh -T git@github.com # è®¾ç½®é»˜è®¤ç¼–è¾‘ä¸ºvim git config --global core.editor \u0026#34;vim\u0026#34; ç©è½¬WSL(6)ä¹‹Gité…ç½®\ngitåŒæ—¶é…ç½®Giteeå’ŒGithub\nGitè®¾ç½®æ¢è¡Œç¬¦ä¸ºLF\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/git/","summary":"gitæ“ä½œ # ä¸‹è½½ä»£ç ï¼Œsshæˆ–https ä¸€ç§æ–¹å¼å‡ºé”™æ¢ç”¨å¦ä¸€ç§ git clone # åˆ›å»ºåˆ†æ”¯ git checkout -b br_master # æäº¤ git status git add . git commit # åˆå¹¶åˆ°å‰ä¸€ä¸ªcommit git commit --amend # æ‹‰","title":"git"},{"content":"python logging # logging.yamlï¼š version: 1 disable_existing_loggers: False formatters: simple: format: \u0026#39;%(asctime)s %(levelname)s %(message)s\u0026#39; upgrade: format: \u0026#34;%(asctime)s -Loc %(filename)s -Pid %(process)d -%(name)s -%(levelname)s - %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout all_file_handler: class: logging.handlers.RotatingFileHandler level: DEBUG formatter: upgrade filename: ./logs/all_log.log maxBytes: 10485760 # 10MB backupCount: 50 #ä¿ç•™50ä¸ªlogæ–‡ä»¶ encoding: utf8 server_file_handler: class: logging.handlers.RotatingFileHandler level: INFO # åªåœ¨æ–‡ä»¶ä¸­è®°å½•INFOçº§åˆ«åŠä»¥ä¸Šçš„log formatter: upgrade filename: ./logs/server.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 loggers: server: level: DEBUG #å…è®¸æ‰“å°DEBUGåŠä»¥ä¸Šlog handlers: [server_file_handler] propagate: true #è®¾ä¸ºfalseåˆ™ç¦æ­¢å°†æ—¥å¿—æ¶ˆæ¯ä¼ é€’ç»™çˆ¶çº§è®°å½•å™¨çš„å¤„ç†ç¨‹åºä¸­ root: level: DEBUG handlers: [console, all_file_handler] # logger.py # logging.py from fileinput import filename import os import time import yaml import logging.config import logging import datetime #import coloredlogs class Logger(): def __init__(self, log_name=\u0026#34;log.log\u0026#34;, log_path = \u0026#34;./logs\u0026#34;, default_path = \u0026#34;logging.yaml\u0026#34;, default_level = logging.INFO,env_key = \u0026#34;LOG_CFG\u0026#34;): self.log_name = log_name self.log_path = log_path #time_stamp = time. now = time.strftime(\u0026#39;%Y-%m-%d %H_%M_%S_\u0026#39;) # æ–‡ä»¶çš„å‘½ä»¤ä»¥åŠæ‰“å¼€è·¯å¾„ log_filename = self.log_path + \u0026#34;/\u0026#34; + now + self.log_name with open(file=default_path, mode=\u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;)as file: logging_yaml = yaml.load(stream=file, Loader=yaml.FullLoader) logging_yaml[\u0026#39;handlers\u0026#39;][\u0026#39;all_file_handler\u0026#39;][\u0026#39;filename\u0026#39;] = log_filename print(\u0026#34;logging_yaml \u0026#34;,logging_yaml) handlers = logging_yaml[\u0026#39;handlers\u0026#39;] for key, value in handlers.items(): if \u0026#39;filename\u0026#39; in value: log_path = (os.path.split(value[\u0026#39;filename\u0026#39;])[0]) print(\u0026#34;log_path\u0026#34;) if not os.path.exists(log_path): os.makedirs(log_path) # é…ç½®loggingæ—¥å¿—ï¼šä¸»è¦ä»æ–‡ä»¶ä¸­è¯»å–handlerçš„é…ç½®ã€formatterï¼ˆæ ¼å¼åŒ–æ—¥å¿—æ ·å¼ï¼‰ã€loggerè®°å½•å™¨çš„é…ç½® logging.config.dictConfig(config=logging_yaml) ###è®¾ç½®å®Œæ¯•### # è·å–æ ¹è®°å½•å™¨ï¼šé…ç½®ä¿¡æ¯ä»yamlæ–‡ä»¶ä¸­è·å– root = logging.getLogger() # å­è®°å½•å™¨çš„åå­—ä¸é…ç½®æ–‡ä»¶ä¸­loggerså­—æ®µå†…çš„ä¿æŒä¸€è‡´ server = logging.getLogger(\u0026#34;server\u0026#34;) print(\u0026#34;rootlogger:\u0026#34;, root.handlers) print(\u0026#34;serverlogger:\u0026#34;, server.handlers) print(\u0026#34;å­è®°å½•å™¨ä¸æ ¹è®°å½•å™¨çš„handleræ˜¯å¦ç›¸åŒï¼š\u0026#34;, root.handlers[0] == server.handlers[0]) if __name__ ==\u0026#39;__main__\u0026#39;: Logger() logging.info(\u0026#34;first log\u0026#34;) å‚è€ƒé“¾æ¥ï¼š\nhttps://blog.csdn.net/weixin_43988680/article/details/123528294 https://zhuanlan.zhihu.com/p/425678081 https://blog.csdn.net/qq_35812205/article/details/126480417 https://blog.csdn.net/TracelessLe/article/details/108887001 c log zlog https://blog.csdn.net/twd_1991/article/details/80481920\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/logging/","summary":"python logging # logging.yamlï¼š version: 1 disable_existing_loggers: False formatters: simple: format: \u0026#39;%(asctime)s %(levelname)s %(message)s\u0026#39; upgrade: format: \u0026#34;%(asctime)s -Loc %(filename)s -Pid %(process)d -%(name)s -%(levelname)s - %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout all_file_handler: class: logging.handlers.RotatingFileHandler level: DEBUG formatter: upgrade filename: ./logs/all_log.log maxBytes: 10485760 # 10MB backupCount: 50 #ä¿ç•™50ä¸ªlo","title":"logging"},{"content":"å¤šå¹´ç»éªŒæ€»ç»“ï¼Œå†™å‡ºæœ€æƒŠè‰³çš„ Markdown é«˜çº§ç”¨æ³•\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/markown/","summary":"å¤šå¹´ç»éªŒæ€»ç»“ï¼Œå†™å‡ºæœ€æƒŠè‰³çš„ Markdown é«˜çº§ç”¨æ³•","title":"Markown"},{"content":"æŸ¥çœ‹å¤§å° # æŸ¥çœ‹ç³»ç»Ÿç›®å½•å¤§å° df -lh # æŸ¥çœ‹å½“å‰ç›®å½•ä¸‹æ–‡ä»¶å¤§å° du -h --max-depth=1 æƒé™ chmod chown ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxcommand/","summary":"æŸ¥çœ‹å¤§å° # æŸ¥çœ‹ç³»ç»Ÿç›®å½•å¤§å° df -lh # æŸ¥çœ‹å½“å‰ç›®å½•ä¸‹æ–‡ä»¶å¤§å° du -h --max-depth=1 æƒé™ chmod chown","title":"LinuxCommand"},{"content":"openbenchmark\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/benchmark/","summary":"openbenchmark","title":"benchmark"},{"content":"1.cmakeç®€è¿° CMakeæ˜¯è·¨å¹³å°ç¼–è¯‘ç®¡ç†å·¥å…·,ä¸ºç¬¬ä¸‰æ–¹ä¾èµ–å’Œå¼•å…¥,åˆ›å»ºç¼–è¯‘ç³»ç»Ÿ,ç¨‹åºæµ‹è¯•åŠå®‰è£….Cmakeå·¥å…·ä½¿ç”¨CMakeLists.txtæ–‡ä»¶,è·¨å¹³å°æ‰§è¡Œç›¸åŒç¼–è¯‘å‘½ä»¤,ç”Ÿæˆå¯¹åº”å¹³å°çš„å¯æ‰§è¡Œç¨‹åºæˆ–è€…é“¾æ¥åº“.\nCMakeå·¥ç¨‹ç®€å•ä¾‹å­\ncmake_minimum_required(VERSION 3.12) project(myproj) find_package(Poco REQUIRED COMPONENTS Net Util) add_executable(MyExe) target_source(MyExe PRIVATE \u0026#34;main.cpp\u0026#34;) target_link_library(MyExe PRIVATE Poco::Net PocoUtil) target_complie_definition(MyExe PRIVATE std_cxx_14) 2.Target å’Œå›´ç»• Target çš„é…ç½® C/C++å·¥ç¨‹é€šå¸¸éƒ½æ˜¯ä¸ºäº†ç”Ÿæˆå¯æ‰§è¡Œç¨‹åºæˆ–è€…é“¾æ¥åº“ï¼Œåœ¨ç°ä»£ CMake é‡Œä»–ä»¬è¢«ç»Ÿç§°ä¸ºtargetï¼Œåˆ›å»ºå‘½ä»¤åˆ†åˆ«æ˜¯add_library()å’Œadd_executable()ã€‚å…¶ä¸­é“¾æ¥åº“çš„ç±»å‹åˆåˆ†ä¸ºå¾ˆå¤šç§ï¼Œæœ€å¸¸ç”¨çš„å°±æ˜¯SHAREDä»¥åŠSTATICï¼Œåœ¨å‘½ä»¤ä¸­åŠ å…¥å…³é”®è¯è¿›è¡Œå£°æ˜ï¼šadd_library(MyLib SHARED)ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºtargetçš„åç§°ï¼Œåç»­çš„é…ç½®éƒ½éœ€è¦ç”¨åˆ°è¿™ä¸ªåå­—ã€‚ æŒ‡å®štargetçš„æºæ–‡ä»¶ï¼š\ntarget_source(MyLib PRVIATE \u0026#34;main.cpp\u0026#34; \u0026#34;func.cpp\u0026#34;) PRIVATEå…³é”®è¯ç”¨äºæè¿°å‚æ•°çš„â€œåº”ç”¨èŒƒå›´â€ï¼Œæ­¤å¤–è¿˜æœ‰INTERFACEå’ŒPUBLICä¸¤ç§å¯èƒ½çš„å€¼\nè¾ƒå¤šçš„æºæ–‡ä»¶ï¼Œå¯ä»¥ä½¿ç”¨ CMake çš„fileå‘½ä»¤è¿›è¡Œéå†æ‹¿åˆ°å…¨éƒ¨çš„æºæ–‡ä»¶\nfile(GLOB_RECURSE SRCS ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp) å‘½ä»¤ç¬¬ä¸€ä¸ªå‚æ•°GLOB_RECURSEè¡¨æ˜é€’å½’çš„æŸ¥æ‰¾å­æ–‡ä»¶å¤¹ï¼Œç¬¬äºŒä¸ªå‚æ•°SRCSåˆ™æ˜¯å­˜å‚¨ç»“æœçš„å˜é‡åï¼Œç¬¬ä¸‰ä¸ªå‚æ•°ä¸ºç›®æ ‡æ–‡ä»¶çš„åŒ¹é…æ¨¡å¼ï¼Œæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„ cpp æ–‡ä»¶åï¼Œä»–ä»¬çš„è·¯å¾„ä¼šä»¥å­—ç¬¦ä¸²æ•°ç»„çš„å½¢å¼ä¿å­˜åœ¨ SRCS å˜é‡ä¸­ï¼Œä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼š\ntarget_source(MyLib PRIVATE ${SRCS}) é…ç½®targetæ—¶é€šå¸¸è¿˜éœ€è¦æŒ‡å®šå¤´æ–‡ä»¶ç›®å½•ï¼š\ntarget_include_directories(MyLib PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include/) ç¼–è¯‘æ—¶éœ€è¦çš„è¯­è¨€ç‰¹æ€§ï¼š\ntarget_compile_features(MyLib PRIVATE std_cxx_14) ç¼–è¯‘æ—¶çš„å®å®šä¹‰ï¼š\ntarget_compile_definitions(MyLib PRIVATE LogLevel=3) å‚æ•°æƒ³ç›´æ¥ä¼ ç»™åº•å±‚çš„ç¼–è¯‘å™¨ï¼ˆæ¯”å¦‚ gcc, clang, clï¼‰ï¼Œå¯ä»¥ä½¿ç”¨\ntarget_compile_options(MyLib PRIVATE -Werror -Wall -Wextra) 3.Build Specification å’Œ Usage Requirement C/C++é€šè¿‡ include å¤´æ–‡ä»¶çš„æ–¹å¼å¼•å…¥ä¾èµ–ï¼Œåœ¨åŠ¨æ€æˆ–é™æ€é“¾æ¥åå¯ä»¥è°ƒç”¨ä¾èµ–å®ç°ã€‚ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºå¯èƒ½ä¼šä¾èµ–é“¾æ¥åº“ï¼Œé“¾æ¥åº“ä¹ŸåŒæ ·å¯èƒ½ä¾èµ–å…¶ä»–çš„é“¾æ¥åº“ CMake æä¾›çš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼Œåœ¨å¯¹ target è¿›è¡Œé…ç½®æ—¶ï¼Œå¯ä»¥è§„å®šé…ç½®çš„ç±»å‹ï¼Œåˆ†ä¸º build specification å’Œ usage requirement ä¸¤ç±»ï¼Œä¼šå½±å“é…ç½®çš„åº”ç”¨èŒƒå›´ã€‚Build specification ç±»å‹çš„é…ç½®ä»…åœ¨ç¼–è¯‘çš„æ—¶å€™éœ€è¦æ»¡è¶³ï¼Œé€šè¿‡PRIVATEå…³é”®å­—å£°æ˜ï¼›Usage requirement ç±»å‹çš„é…ç½®åˆ™æ˜¯åœ¨ä½¿ç”¨æ—¶éœ€è¦æ»¡è¶³ï¼Œå³åœ¨å…¶ä»–é¡¹ç›®é‡Œï¼Œä½¿ç”¨æœ¬é¡¹ç›®å·²ç¼–è¯‘å¥½çš„ target æ—¶éœ€è¦æ»¡è¶³ï¼Œè¿™ç§ç±»å‹çš„é…ç½®ä½¿ç”¨INTERFACEå…³é”®è¯å£°æ˜ã€‚åœ¨å®é™…å·¥ç¨‹ä¸­ï¼Œæœ‰å¾ˆå¤šé…ç½®åœ¨ç¼–è¯‘æ—¶ä»¥åŠè¢«ä½¿ç”¨æ—¶éƒ½éœ€è¦è¢«æ»¡è¶³çš„ï¼Œè¿™ç§é…ç½®é€šè¿‡PUBLICå…³é”®è¯è¿›è¡Œå£°æ˜ã€‚\nä¸€ä¸ª libraryï¼Œåœ¨ç¼–è¯‘æ—¶é™æ€é“¾æ¥äº† Boostï¼Œåœ¨æˆ‘ä»¬çš„å®ç°æ–‡ä»¶ä¸­ä½¿ç”¨äº† c++14 çš„ç‰¹æ€§ï¼Œå¹¶ç”¨åˆ°äº† Boost çš„å¤´æ–‡ä»¶å’Œå‡½æ•°ã€‚éšåæˆ‘ä»¬å¯¹å¤–å‘å¸ƒäº†è¿™ä¸ªåº“ï¼Œå…¶ä¸­æœ‰å¤´æ–‡ä»¶å’Œé¢„ç¼–è¯‘å¥½çš„åŠ¨æ€é“¾æ¥åº“ã€‚å°½ç®¡æˆ‘ä»¬çš„å®ç°ä»£ç é‡Œç”¨äº† C++14ï¼Œä½†åœ¨å¯¹å¤–æä¾›çš„å¤´æ–‡ä»¶ä¸­åªç”¨åˆ° C++03 çš„è¯­æ³•ï¼Œä¹Ÿæ²¡æœ‰å¼•å…¥ä»»ä½• Boost çš„ä»£ç ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œå½“å…¶ä»–å·¥ç¨‹åœ¨ä½¿ç”¨æˆ‘ä»¬çš„ library æ—¶ï¼Œå…¶ä½¿ç”¨çš„ç¼–è¯‘å™¨ä¸éœ€è¦å¼€å¯ C++14 çš„æ”¯æŒï¼Œå¼€å‘ç¯å¢ƒä¸‹ä¹Ÿä¸éœ€è¦å®‰è£… Boostã€‚æˆ‘ä»¬ library çš„ CMake é…ç½®ä¸­å¯ä»¥è¿™ä¹ˆå†™ï¼š\ntarget_compile_features(MyLib PRIVATE cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) PRIVATE è¯´æ˜ c++14 çš„æ”¯æŒåªåœ¨ç¼–è¯‘æ—¶éœ€è¦ç”¨åˆ°ï¼ŒBoost åº“çš„é“¾æ¥ä¹Ÿä»…åœ¨ç¼–è¯‘æ—¶éœ€è¦ã€‚ä½†å¦‚æœæˆ‘ä»¬å¯¹å¤–æä¾›çš„å¤´æ–‡ä»¶ä¸­ä¹Ÿä½¿ç”¨äº† C++14ï¼Œé‚£ä¹ˆå°±éœ€è¦ä½¿ç”¨ PUBLIC ä¿®é¥°ï¼Œæ”¹ä¸ºï¼š\ntarget_compile_features(MyLib PUBLIC cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) å½“ library æ˜¯ header-only æ—¶ï¼Œæˆ‘ä»¬çš„å·¥ç¨‹æ˜¯ä¸éœ€è¦å•ç‹¬ç¼–è¯‘çš„ï¼Œå› æ­¤ä¹Ÿå°±æ²¡æœ‰ build specificationï¼Œé€šè¿‡INTERFACEä¿®é¥°é…ç½®å³å¯\narget_compile_features(MyLib INTERFACE cxx_std_14) Usage requirement ç±»å‹çš„é…ç½®ï¼Œå³é€šè¿‡INTERFACEæˆ–æ˜¯PUBLICä¿®é¥°çš„é…ç½®æ˜¯ä¼šä¼ é€’çš„ï¼Œæ¯”å¦‚ LibA ä¾èµ– LibB åï¼Œä¼šç»§æ‰¿ LibB çš„ usage requirementï¼Œæ­¤å LibC ä¾èµ– LibB æ—¶ï¼ŒLibA å’Œ libB çš„ usage requirement éƒ½ä¼šç»§æ‰¿ä¸‹æ¥ï¼Œ\n4.å¯»æ‰¾å’Œä½¿ç”¨é“¾æ¥åº“ C/C++æ ‡å‡†æ²¡æœ‰è§„èŒƒåº“çš„å®‰è£…ä½ç½®å’Œå®‰è£…å½¢å¼ï¼Œé€šè¿‡ CMake æä¾›çš„æ–¹æ¡ˆå¯»æ‰¾ä¾èµ–ï¼Œä¸å…‰å¯ä»¥å®šä½åˆ°å¤´æ–‡ä»¶ç›®å½•å’Œé“¾æ¥åº“è·¯å¾„ï¼Œè¿˜èƒ½å¤Ÿè·å–åˆ°åº“çš„ usage requirementã€‚ åœ¨ CMake ä¸­å¯»æ‰¾ç¬¬ä¸‰æ–¹åº“çš„å‘½ä»¤ä¸ºfind_packageï¼Œå…¶èƒŒåçš„å·¥ä½œæ–¹å¼æœ‰ä¸¤ç§ï¼Œä¸€ç§åŸºäº Config File çš„æŸ¥æ‰¾ï¼Œå¦ä¸€ç§åˆ™æ˜¯åŸºäº Find File çš„æŸ¥æ‰¾ã€‚åœ¨æ‰§è¡Œfind_packageæ—¶ï¼Œå®é™…ä¸Š CMake éƒ½æ˜¯åœ¨æ‰¾è¿™ä¸¤ç±»æ–‡ä»¶ï¼Œæ‰¾åˆ°åä»ä¸­è·å–å…³äºåº“çš„ä¿¡æ¯ã€‚\n4.1 é€šè¿‡ Config file æ‰¾åˆ°ä¾èµ– Config File æ˜¯ä¾èµ–çš„å¼€å‘è€…æä¾›çš„ cmake è„šæœ¬ï¼Œé€šå¸¸ä¼šéšé¢„ç¼–è¯‘å¥½çš„äºŒè¿›åˆ¶ä¸€èµ·å‘å¸ƒï¼Œä¾›ä¸‹æ¸¸çš„ä½¿ç”¨è€…ä½¿ç”¨ã€‚åœ¨ Config file é‡Œï¼Œä¼šå¯¹åº“é‡ŒåŒ…å«çš„ target è¿›è¡Œæè¿°ï¼Œè¯´æ˜ç‰ˆæœ¬ä¿¡æ¯ä»¥åŠå¤´æ–‡ä»¶è·¯å¾„ã€é“¾æ¥åº“è·¯å¾„ã€ç¼–è¯‘é€‰é¡¹ç­‰ usage requirement\nCMake å¯¹ Config file çš„å‘½åæ˜¯æœ‰è§„å®šçš„ï¼Œå¯¹äºfind_package(ABC)è¿™æ ·ä¸€æ¡å‘½ä»¤ï¼ŒCMake åªä¼šå»å¯»æ‰¾ABCConfig.cmakeæˆ–æ˜¯abc-config.cmakeã€‚CMake é»˜è®¤å¯»æ‰¾çš„è·¯å¾„å’Œå¹³å°æœ‰å…³ï¼Œåœ¨ Linux ä¸‹å¯»æ‰¾è·¯å¾„åŒ…æ‹¬/usr/lib/cmakeä»¥åŠ/usr/lib/local/cmakeï¼Œåœ¨è¿™ä¸¤ä¸ªè·¯å¾„ä¸‹å¯ä»¥å‘ç°å¤§é‡çš„ Config Fileï¼Œä¸€èˆ¬åœ¨å®‰è£…æŸä¸ªåº“æ—¶ï¼Œå…¶è‡ªå¸¦çš„ Config file ä¼šè¢«æ”¾åˆ°è¿™é‡Œæ¥ã€‚\n4.2 é€šè¿‡ Find file æ‰¾åˆ°ä¾èµ– å¯¹äºfind_package(ABC)å‘½ä»¤ï¼Œå¦‚æœ CMake æ²¡æœ‰æ‰¾åˆ° Config fileï¼Œä»–è¿˜ä¼šå»è¯•ç€å¯»æ‰¾FindABC.cmakeã€‚Find file åœ¨åŠŸèƒ½ä¸Šå’Œ Config file ç›¸åŒï¼ŒåŒºåˆ«åœ¨äº Find file æ˜¯ç”±å…¶ä»–äººç¼–å†™çš„ï¼Œè€Œéåº“çš„å¼€å‘è€…ã€‚å¦‚æœä½ ä½¿ç”¨çš„æŸä¸ªåº“æ²¡æœ‰æä¾› Config fileï¼Œä½ å¯ä»¥å»ç½‘ä¸Šæœæœ Find file æˆ–è€…è‡ªå·±å†™ä¸€ä¸ªï¼Œç„¶ååŠ å…¥åˆ°ä½ çš„ CMake å·¥ç¨‹ä¸­ã€‚\nCMake å®˜æ–¹ä¸ºæˆ‘ä»¬å†™å¥½äº†å¾ˆå¤š Find fileï¼Œåœ¨CMake Documentationè¿™ä¸€é¡µé¢å¯ä»¥çœ‹åˆ°ï¼ŒOpenGLï¼ŒOpenMPï¼ŒSDL è¿™äº›çŸ¥åçš„åº“å®˜æ–¹éƒ½ä¸ºæˆ‘ä»¬å†™å¥½äº† Find è„šæœ¬ï¼Œå› æ­¤ç›´æ¥è°ƒç”¨ find_package å‘½ä»¤å³å¯ã€‚ä½†ç”±äºåº“çš„å®‰è£…ä½ç½®å¹¶ä¸æ˜¯å›ºå®šçš„ï¼Œè¿™äº› Find è„šæœ¬ä¸ä¸€å®šèƒ½æ‰¾åˆ°åº“ï¼Œæ­¤æ—¶æ ¹æ® CMake æŠ¥é”™çš„æç¤ºè®¾ç½®å¯¹åº”å˜é‡å³å¯ï¼Œé€šå¸¸æ˜¯éœ€è¦æä¾›å®‰è£…è·¯å¾„ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ Find file è·å–åˆ°åº“çš„ usage requirementã€‚ä¸è®ºæ˜¯ Config file è¿˜æ˜¯ Find fileï¼Œå…¶ç›®çš„éƒ½ä¸åªæ˜¯æ‰¾åˆ°åº“è¿™ä¹ˆç®€å•ï¼Œè€Œæ˜¯å‘Šè¯‰ CMake å¦‚ä½•ä½¿ç”¨è¿™ä¸ªåº“ã€‚ åº“ CMake å®˜æ–¹ä¹Ÿæ²¡æœ‰æä¾› Find fileï¼Œè¿™æ—¶å€™å°±è¦è‡ªå·±å†™äº†æˆ–è€…é æœç´¢äº†ï¼Œå†™å¥½åæ”¾åˆ°æœ¬é¡¹ç›®çš„ç›®å½•ä¸‹ï¼Œä¿®æ”¹CMAKE_MODULE_PATHè¿™ä¸ª CMAKE å˜é‡ï¼š\nlist(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake) ${CMAKE_SOURCE_DIR}/cmakeç›®å½•ä¸‹çš„ Find file å°±å¯ä»¥è¢« CMake æ‰¾åˆ°äº†ã€‚ é€šè¿‡ CMake çš„find_libraryå’Œfind_pathä¸¤ä¸ªå‘½ä»¤å°±å¯ä»¥å®Œæˆä»»åŠ¡ï¼š\nfind_library(MPI_LIBRARY NAMES mpi HINTS \u0026#34;${CMAKE_PREFIX_PATH}/lib\u0026#34; ${MPI_LIB_PATH} # å¦‚æœé»˜è®¤è·¯å¾„æ²¡æ‰¾åˆ°libmpi.soï¼Œè¿˜ä¼šå»MPI_LIB_PATHæ‰¾ï¼Œä¸‹æ¸¸ä½¿ç”¨è€…å¯ä»¥è®¾ç½®è¿™ä¸ªå˜é‡å€¼ ) find_path(MPI_INCLUDE_DIR NAMES mpi.h PATHS \u0026#34;${CMAKE_PREFIX_PATH}/include\u0026#34; ${MPI_INCLUDE_PATH} # å¦‚æœé»˜è®¤è·¯å¾„æ²¡æ‰¾åˆ°mpi.hï¼Œè¿˜ä¼šå»MPI_INCLUDE_PATHæ‰¾ï¼Œä¸‹æ¸¸ä½¿ç”¨è€…å¯ä»¥è®¾ç½®è¿™ä¸ªå˜é‡å€¼ ) 4.3.find_package çš„å¤„ç† find_packageè¿™ä¸ªå‘½ä»¤ï¼Œè¿™ä¸ªå‘½ä»¤å¯ä»¥æŒ‡å®šå¾ˆå¤šå‚æ•°ï¼Œæ¯”å¦‚æŒ‡å®šç‰ˆæœ¬ï¼ŒæŒ‡å®šå…·ä½“çš„æ¨¡å—ç­‰ç­‰ã€‚ä»¥ SFML å¤šåª’ä½“åº“ä¸ºä¾‹ï¼Œå…¶åŒ…å«äº† network æ¨¡å—ï¼Œaudio æ¨¡å—ï¼Œgraphic æ¨¡å—ç­‰ç­‰ï¼Œä½†æˆ‘å¾ˆå¤šæ—¶å€™åªç”¨åˆ° graphic æ¨¡å—ï¼Œé‚£ä¹ˆå…¶ä»–çš„æ¨¡å—å¯¹åº”çš„é“¾æ¥åº“ä¸éœ€è¦è¢«é“¾æ¥ï¼Œäºæ˜¯ CMake è„šæœ¬å¯ä»¥è¿™ä¹ˆå†™ï¼š\n# è¦æ±‚å¤§ç‰ˆæœ¬å·ä¸º2çš„SFMLåº“çš„graphicæ¨¡å— find_package(SFML 2 COMPONENTS graphics REQUIRED) # SFMLæä¾›çš„targetåå­—ä¸ºsfml-graphics target_link_libraries(MyEXE PRIVATE sfml-graphics) 5.ä½¿ç”¨ CMake æ¥ç¼–è¯‘ CMake ç”Ÿæˆå¥½ç¼–è¯‘ç¯å¢ƒåï¼Œåº•å±‚çš„ make, ninja, MSBuild ç¼–è¯‘å‘½ä»¤éƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼Œä½† CMake æä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„æ–¹æ³•è¿›è¡Œç¼–è¯‘ï¼š\ncmake --build . ä½¿ç”¨\u0026ndash;buildflagï¼ŒCMake å°±ä¼šè°ƒç”¨åº•å±‚çš„ç¼–è¯‘å‘½ä»¤ï¼Œåœ¨è·¨å¹³å°æ—¶ååˆ†æ–¹ä¾¿ã€‚ å¯¹äº Visual Studioï¼Œå…¶ Debug å’Œ Release ç¯å¢ƒæ˜¯åŸºäº configuration çš„ï¼Œå› æ­¤CMAKE_BUILD_TYPEå˜é‡æ— æ•ˆï¼Œéœ€è¦åœ¨ build æ—¶æŒ‡å®šï¼š\ncmake --build . --config Release å‚è€ƒé“¾æ¥: cmake https://ukabuer.me/blog/more-modern-cmake/ Makefile ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/cmake/","summary":"\u003ch2 id=\"1cmakeç®€è¿°\"\u003e1.cmakeç®€è¿°\u003c/h2\u003e\n\u003cp\u003eâ€‚CMakeæ˜¯è·¨å¹³å°ç¼–è¯‘ç®¡ç†å·¥å…·,ä¸ºç¬¬ä¸‰æ–¹ä¾èµ–å’Œå¼•å…¥,åˆ›å»ºç¼–è¯‘ç³»ç»Ÿ,ç¨‹åºæµ‹è¯•åŠå®‰è£….Cmakeå·¥å…·ä½¿ç”¨CMakeLists.txtæ–‡ä»¶,è·¨å¹³å°æ‰§è¡Œç›¸åŒç¼–è¯‘å‘½ä»¤,ç”Ÿæˆå¯¹åº”å¹³å°çš„å¯æ‰§è¡Œç¨‹åºæˆ–è€…é“¾æ¥åº“.\u003c/p\u003e","title":"cmake"},{"content":"ä¸€.ç®€å•å¥å­åˆ†æ è‹±è¯­å¥å­= ä¸»å¹²+ä¿®é¥°æˆåˆ† åˆ†æå¥å­ç»“æ„: ä¸€ä¸ªä¸­å¿ƒ + ä¸¤ä¸ªè¦ç‚¹ ä¸€ä¸ªä¸­å¿ƒ: åŠ¨è¯. å¥å­å¿…é¡»å³åŠ¨è¯ ä¸¤ä¸ªè¦ç‚¹: ä¸»è¯­ + è°“è¯­. è°“è¯­æ˜¯åŠ¨è¯,ä¸»è¯­ä¸ºåŠ¨ä½œçš„æ‰§è¡Œè€…æˆ–æ¥å—è€…. å¥å­çš„æ ¸å¿ƒæ˜¯ä¸»è°“ç»“æ„\nnä¸ªä¸»è¯­+1ä¸ªè°“è¯­ æˆ–è€… 1ä¸ªä¸»è¯­+nä¸ªè°“è¯­ï¼Œå°±å¯ä»¥ç»„æˆç®€å•å¥ã€‚å…¶ä»–çš„å®šçŠ¶è¡¥è¯­ç­‰éƒ½æ˜¯å¥å­çš„é™„å±æˆåˆ†ã€‚ä¸»è¯­éƒ¨åˆ†å½¢å¼æ¯”è¾ƒå•ä¸€ï¼Œé€šå¸¸ç”±åè¯æ€§çš„ç»“æ„æ¥æ‹…ä»»ã€‚è°“è¯­éƒ¨åˆ†çš„å½¢å¼å˜åŒ–è¾ƒå¤šï¼Œäº”ç§åŸºæœ¬å¥å‹å®é™…å°±æ˜¯é€šè¿‡ä¸åŒçš„è°“è¯­éƒ¨åˆ†ç»“æ„æ¥è¡¨è¾¾äº”ç§ç±»å‹çš„å«ä¹‰ã€‚ä¸ç®¡è°“è¯­éƒ¨åˆ†å¦‚ä½•å˜åŒ–ï¼Œå®ƒéƒ½ç”±åŠ¨è¯èµ·å¤´ï¼Œå¹¶æ‰¿æ‹…ä¸»è¦çš„è¡¨æ„åŠŸèƒ½ã€‚\nè‹±è¯­çš„å¥å­ç»“æ„åˆ†ä¸ºä¸‰ç§:ç®€å•å¥,å¹¶åˆ—å¥,å¤åˆå¥.ç®€å•å¥åˆåˆ†ä¸ºäº”ç§åŸºæœ¬å¥å‹.\n{% pullquote mindmap mindmap-md %}\nè‹±æ–‡å¥å­ ç®€å•å¥ ä¸» + è°“ ä¸» + è°“ + å®¾ ä¸» + è°“ + å®¾ + å®¾è¡¥ ä¸» + è°“ + é—´å®¾ + ç›´å®¾ ä¸» + ç³» + è¡¨ å¤åˆå¥ åè¯æ€§ä»å¥ ä¸»è¯­ä»å¥ å®¾è¯­ä»å¥ åŒä½è¯­ä»å¥ è¡¨è¯­ä»å¥ å®šè¯­ä»å¥ çŠ¶è¯­ä»å¥ æ—¶é—´çŠ¶è¯­ä»å¥ åœ°ç‚¹çŠ¶è¯­ä»å¥ æ¡ä»¶çŠ¶è¯­ä»å¥ ç»“æœçŠ¶è¯­ä»å¥ è®©æ­¥çŠ¶è¯­ä»å¥ ç›®çš„çŠ¶è¯­ä»å¥ ç‰¹æ®Šå¥å¼ å¼ºè°ƒå¥ è™šæ‹Ÿè¯­æ°” å€’è£…å¥ ç±»å‹ é™ˆè¿°å¥ ç¥ˆä½¿å¥ æ„Ÿå¹å¥ ç–‘é—®å¥ {% endpullquote %}\nè‹±è¯­è¯­æ³•ä»æ•´ä½“ä¸Šæ¥è®²æ˜¯é€šè¿‡äº”éƒ¨åˆ†æ¥ç»„æˆ 1ã€ç®€å•å¥ 2ã€å¹¶åˆ—å¥ã€å¤åˆå¥ 3ã€ä¸‰å¤§ä»å¥ 4ã€ç‰¹æ®Šå¥å¼ 5ã€ç±»å‹\nè¡¥è¯­ è¡¥è¯­æ˜¯å’Œè¡¨æ„ä¸å®Œå…¨çš„åŠ¨è¯æ¯æ¯ç›¸å…³çš„ã€‚åœ¨ç¬¬ä¸‰ç§åŸºæœ¬å¥å‹ä¸­ï¼Œè”ç³»åŠ¨è¯å°†ä¸»è¯­å’Œè¡¥è¯­åœ¨æŸä¸ªæ„ä¹‰å±‚é¢ä¸Šå¯¹ç­‰èµ·æ¥ã€‚ ä¿®é¥°æˆåˆ† ä»‹è¯çŸ­è¯­ ä»å¥ éè°“è¯­åŠ¨è¯ æ—¶é—´çŠ¶è¯­ è®ºä¸»è¯­çš„è¡¥è¯­ï¼Œè€Œåå°†å®¾è¯­çš„è¡¥è¯­ä½œä¸ºä¸€ç§å˜å½¢æ¥è®¨è®º\n1.1 S + V ï¼ˆä¸»+è°“ï¼‰ å¥å­ä¸å¯æˆ–ç¼ºçš„ä¸¤éƒ¨åˆ†. åè¯/ä»£è¯/ä¸å®šå¼/åŠ¨åè¯ + åŠ¨è¯ è°“è¯­åŠ¨è¯å¯ä»¥è¡¨è¾¾å®Œæ•´çš„æ„æ€ï¼Œè¿™ç±»åŠ¨è¯ä¸ºä¸åŠç‰©åŠ¨è¯ï¼ˆviï¼‰.\n1.2 S + V + C ï¼ˆä¸»+ç³»+è¡¨ï¼‰ ä¸»è¯­ +ç³»åŠ¨è¯ +è¡¨è¯­\nè¡¨è¯­è¯´æ˜ä¸»è¯­çš„çŠ¶æ€å’Œæ€§è´¨ï¼Œå¯ä»¥æ˜¯åè¯ï¼Œå½¢å®¹è¯ï¼Œå‰¯è¯ï¼ŒçŸ­è¯­ç­‰ã€‚\nç³»åŠ¨è¯åŒ…æ‹¬ï¼š\na. be åŠ¨è¯ï¼Œam, is, are, was, were;\nb. è¡¨æ„Ÿå®˜ï¼šfeel(æ‘¸èµ·æ¥åƒæ˜¯), smell, sound(å¬èµ·æ¥æ˜¯), taste(å°èµ·æ¥æ˜¯), look(çœ‹èµ·æ¥æ˜¯);\nc. è¡¨å˜åŒ–ï¼šbecome(æˆä¸º), grow, turn(è½¬å˜ä¸º), go, get, fall;\nd. è¡¨çŠ¶æ€ï¼šremain(ä¾æ—§æ˜¯), keep, hold, stay(ä»ç„¶æ˜¯), seem(ä¼¼ä¹æ˜¯).\nappear æ˜¾å¾—åƒæ˜¯ prove è¯å®ä¸º become æˆä¸º make ä½œä¸º\n1.3 S + V + O ï¼ˆä¸»+è°“+å®¾ï¼‰ ä¸»è¯­+è°“è¯­+å®¾è¯­\nè°“è¯­ä¸€èˆ¬ä¸ºåŠç‰©åŠ¨è¯ï¼ˆvt.ï¼‰ï¼Œåé¢å¿…é¡»è¦è·Ÿå®¾è¯­æ‰èƒ½è¡¨è¾¾å®Œæ•´çš„æ„æ€ã€‚å®¾è¯­æ˜¯è°“è¯­åŠ¨è¯åŠ¨ä½œçš„æ‰¿å—è€…ã€‚\n1.4 S + V + O + Oï¼ˆä¸»+è°“+é—´å®¾(äºº)+ç›´å®¾(ç‰©)ï¼‰ è°“è¯­åŠ¨è¯å¿…é¡»è¦è·Ÿä¸¤ä¸ªå®¾è¯­æ‰èƒ½è¡¨è¾¾å®Œæ•´æ„æ€ã€‚ä¸¤ä¸ªå®¾è¯­åˆ†åˆ«æ˜¯åŠ¨ä½œçš„ç›´æ¥æ‰¿å—è€…ï¼ˆä¸€èˆ¬æ˜¯ç‰©ï¼‰å’Œé—´æ¥æ‰¿å—è€…ï¼ˆä¸€èˆ¬æ˜¯äººï¼‰ã€‚ e.g.,\ngive sb sth = give sth to sb\ntell sb sth = tell sth to sb\n1.5 S + V + O + Cï¼ˆä¸»+è°“+å®¾+å®¾è¡¥ï¼‰ æ­¤ç§æƒ…å†µï¼ŒåŠ¨è¯è™½ç„¶è·Ÿäº†å®¾è¯­ï¼Œä½†å¥å­æ„æ€ä¸å®Œæ•´ï¼Œéœ€è¦è·Ÿä¸Šä¸€ä¸ªè¡¥è¶³è¯­ï¼Œå¯¹å®¾è¯­è¿›è¡Œè§£é‡Šè¯´æ˜ï¼Œå¥å­æ„æ€æ‰èƒ½å®Œæ•´é€šé¡ºã€‚ ä¸»è¯­çš„è¡¥è¯­ç”¨æ¥è¡¨ç¤ºä¸»è¯­æ˜¯ä»€ä¹ˆã€‚ç±»ä¼¼åœ°ï¼Œå®¾è¯­çš„è¡¥è¯­ç”¨æ¥è¡¨ç¤ºå®¾è¯­æ˜¯ä»€ä¹ˆã€‚åœ¨ S + V + O + C è¿™ä¸ªå¥å‹å½“ä¸­ï¼Œå®¾è¯­å’Œè¡¥è¯­ä¹‹é—´è™½ç„¶æ²¡æœ‰åŠ¨è¯å­˜åœ¨ã€‚ä½†æ˜¯å¥å­å¯ä»¥å˜å½¢æˆï¼šS + V + that + O + V + C çš„å½¢å¼ï¼Œä¹Ÿå°±æ˜¯å°†åŸæœ¬çš„å®¾è¯­å’Œè¡¥è¯­ä»¥ä»å¥çš„å½¢å¼å‡ºç°ã€‚å› æ­¤ï¼Œå¯ä»¥è®¤ä¸ºå®¾è¯­å’Œè¡¥è¯­ä¹‹é—´æœ‰ã€Œéšè—çš„ã€åˆ¤æ–­åŠ¨è¯ã€Œæ˜¯ã€çš„å­˜åœ¨ã€‚\nThere be å¥å‹\nThere be å¥å‹è¡¨ç¤ºäºº/ç‰©çš„å­˜åœ¨ã€‚å¥å­ç»“æ„ï¼Œå°±æ˜¯There be + ä¸»è¯­+å…¶ä»–éƒ¨åˆ†\n1.ä¸»è¯­ï¼šå¥å­æ‰€é™ˆè¿°çš„å¯¹è±¡ã€‚ 2.è°“è¯­ï¼šä¸»è¯­å‘å‡ºçš„åŠ¨ä½œã€‚ä¸€èˆ¬æ˜¯æœ‰åŠ¨ä½œæ„ä¹‰çš„åŠ¨è¯ã€‚ 3. å®¾è¯­ï¼šåˆ†ä¸ºåŠ¨è¯å®¾è¯­å’Œä»‹è¯å®¾è¯­ï¼Œå±äºåŠ¨ä½œçš„æ‰¿å—è€…ã€‚ 4. ç³»åŠ¨è¯ï¼šè¡¨ç¤ºçŠ¶æ€æˆ–çŠ¶æ€å˜åŒ–çš„åŠ¨è¯ï¼Œæ²¡æœ‰å®é™…çš„åŠ¨ä½œæ„ä¹‰ã€‚å¦‚ be, æ„Ÿå®˜ç³»åŠ¨è¯ï¼ˆlook, sound, smell, taste å’Œ feelï¼‰ã€ä¿æŒç±»ç³»åŠ¨è¯ï¼ˆkeep, stay å’Œ remainï¼‰ã€çŠ¶æ€å˜åŒ–ç±»ç³»åŠ¨è¯ï¼ˆbecomeã€getã€turn å’Œ goï¼‰ç­‰ã€‚ 5. è¡¨è¯­ï¼šç´§è·Ÿç³»åŠ¨è¯åé¢çš„æˆåˆ†ã€‚ 6. å®šè¯­ï¼šä¿®é¥°åè¯æˆ–ä»£è¯çš„æˆåˆ†ã€‚ 7. çŠ¶è¯­ï¼š ä¿®é¥°å½¢å®¹è¯ã€å‰¯è¯ã€åŠ¨è¯æˆ–å¥å­çš„æˆåˆ†ã€‚ 8. è¡¥è¯­ï¼šåˆ†ä¸ºå®¾è¯­è¡¥è¶³è¯­å’Œä¸»è¯­è¡¥è¶³è¯­ã€‚æ˜¯å¯¹å®¾è¯­å’Œä¸»è¯­çš„è¡¥å……è¯´æ˜ï¼Œä¸å…¶æœ‰ä¸»åŠ¨æˆ–è¢«åŠ¨çš„é€»è¾‘å…³ç³»ã€‚\nå‚è€ƒé“¾æ¥: https://liam.page/2014/06/21/basic-sentence-and-the-complement/ https://www.zhihu.com/question/30030877/answer/768501967\nå‚è€ƒæ•°æ® ã€Šè¯­æ³•ä¿±ä¹éƒ¨ã€‹\nå¤æ‚å¥:ä»ç®€å•å¥æ¼”åŒ–è€Œæ¥\nç®€å•å¥æ²¡æœ‰ä»€ä¹ˆå¥åºçš„è°ƒæ•´ï¼Œæ‰€ä»¥ç¿»è¯‘èµ·æ¥åŸºæœ¬æ²¡æœ‰ä»€ä¹ˆéš¾åº¦ã€‚\nè‹±è¯­ä¸­çš„ä¿®é¥°æˆåˆ†ï¼Œåˆ†å®šè¯­å’ŒçŠ¶è¯­ä¸¤ç§æƒ…å†µã€‚ è‹±è¯­å¥å­ = ä¸»å¹²(äº”ç§åŸºæœ¬å¥å‹) + ä¿®é¥°æˆåˆ†(å®šè¯­+çŠ¶è¯­)\näºŒã€å¹¶åˆ—å¥ã€å¤åˆå¥ ç®€å•å¥é€šè¿‡ä¸åŒçš„è¿æ¥è¯å°±æˆä¸ºäº†ä¸åŒçš„å¥å­ï¼Œé€šè¿‡å¹¶åˆ—è¯æˆäº†å¹¶åˆ—å¥ï¼Œé€šè¿‡ä»å±è¿è¯æˆäº†å¤åˆå¥ã€‚ä¸‹é¢æˆ‘ä»¬å°±ä¸€ä¸€è®²è§£ ï¼š\nå¹¶åˆ—å¥ï¼šç®€å•å¥+å¹¶åˆ—è¯+ç®€å•å¥\nå¹¶åˆ—è¯ä¸€èˆ¬æœ‰ï¼šand / or / but / so /while / yet / for / however\n1ï¼‰ï¼šè¡¨ç¤ºå¹¶åˆ—ï¼šand, not only\u0026hellip;but also\u0026hellip; , neither\u0026hellip;nor\u0026hellip;\nHer father is a doctor and her mother is a teacher .\n2ï¼‰ï¼šè¡¨ç¤ºé€‰æ‹©ï¼šor, or else, otherwise, either\u0026hellip;or\u0026hellip;\nHurry or you won\u0026rsquo;t make the train.\n3ï¼‰ï¼šè¡¨ç¤ºå¯¹æ¯”ã€è½¬æŠ˜: but, while , yet , however , never ,\nI like tea while she likes coffee .\n4ï¼‰ï¼šè¡¨ç¤ºåŸå› ï¼šfor\nI am thirsty , for it is hot .\nå¤åˆå¥ï¼šç®€å•å¥+ä»å±è¿è¯+ç®€å•å¥\nä»å±è¿è¯æœ‰ï¼šthat / wether/ if\nå¤åˆå¥å…¶å®å°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„ä¸‰å¤§ä»å¥ï¼Œ\nä¸‰.ä¸‰å¤§ä»å¥ 1ã€åè¯æ€§ä»å¥\nå½“åè¯æ€§ä»å¥ä½œä¸ºå¥å­çš„ä¸åŒæˆåˆ†æ—¶ï¼Œåˆè¢«ç§°å‘¼ä¸ºä¸åŒçš„åå­—ã€‚\nå½“ä½œä¸ºä¸»è¯­æ—¶ï¼Œç§°ä¸ºä¸»è¯­ä»å¥ã€‚\nå½“ç§°ä¸ºå®¾è¯­æ—¶ï¼Œç§°ä¸ºå®¾è¯­ä»å¥ï¼ŒåŒæ ·è¡¨è¯­ä»å¥ä»¥åŠåŒä½è¯­ä»å¥ã€‚ä»¥ä¸‹æˆ‘ä»¬æ¥ä¸¾ä¸ªæ —å­ ï¼š\nä¸»è¯­ä»å¥ What she said is wrong .\nå®¾è¯­ä»å¥ I said that she was wrong.\nè¡¨è¯­ä»å¥ The fact is that he doesnâ€™t really try.\nåŒä½è¯­ä»å¥ The news that he will come back is ture.\nè®°ä½ä¸€ç‚¹ï¼Œä¸ç®¡ä»€ä¹ˆä»å¥ï¼Œä½ æŠŠå®ƒå½“æˆä¸€ä¸ªâ€é•¿ä¸€ç‚¹çš„åè¯â€ã€‚\né‚£å¦‚æœè¿™ä¸ªé•¿åè¯åœ¨å¥å­ä¸­ä½œä¸»è¯­ï¼Œå°±æ˜¯ä¸»è¯­ä»å¥ï¼Œä½œå®¾è¯­å°±æ˜¯å®¾è¯­ä»å¥ã€‚\nåŒä½è¯­ä»å¥å°±æ˜¯ç›¸å½“äºä¸€ä¸ªé•¿ç‚¹çš„åè¯å¯¹å¦å¤–ä¸€ä¸ªæŠ½è±¡åè¯è¿›è¡Œè§£é‡Šè¯´æ˜ã€‚\n2ã€å®šè¯­ä»å¥\nä¿®é¥°é™å®šåè¯ï¼Œæ±‰è¯­ä¸­â€œçš„â€å‰é¢çš„å†…å®¹ã€‚\nå…³ç³»ä»£è¯å¼•å¯¼çš„å®šè¯­ä»å¥\n1.whoæŒ‡äººï¼Œåœ¨ä»å¥ä¸­åšä¸»è¯­ Yesterdayâ€‚Iâ€‚helpedâ€‚anâ€‚oldâ€‚manâ€‚whoâ€‚lostâ€‚hisâ€‚way.\n2.â€‚whomæŒ‡äººï¼Œåœ¨å®šè¯­ä»å¥ä¸­å……å½“å®¾è¯­ï¼Œå¸¸å¯çœç•¥ã€‚\nMr.â€‚Lingâ€‚isâ€‚justâ€‚theâ€‚boyâ€‚whomâ€‚Iâ€‚wantâ€‚toâ€‚see\n3.â€‚whichæŒ‡ç‰©ï¼Œåœ¨å®šè¯­ä»å¥ä¸­åšä¸»è¯­æˆ–è€…å®¾è¯­ï¼Œåšå®¾è¯­æ—¶å¯çœç•¥\nThisâ€‚isâ€‚theâ€‚penâ€‚(which)â€‚heâ€‚boughtâ€‚yesterday.\n4.â€‚thatæŒ‡äººæ—¶ï¼Œç›¸å½“äºwhoâ€‚æˆ–è€…whomï¼›æŒ‡ç‰©æ—¶ï¼Œç›¸å½“äºwhichã€‚\n5.â€‚whoseé€šå¸¸æŒ‡äººï¼Œä¹Ÿå¯æŒ‡ç‰©ï¼Œåœ¨å®šè¯­ä»å¥ä¸­åšå®šè¯­ã€‚\næŒ‡çš„æ˜¯è°çš„ã€‚Doâ€‚youâ€‚likeâ€‚theâ€‚bookâ€‚whoseâ€‚coverâ€‚isâ€‚yellow?\nå…³ç³»å‰¯è¯å¼•å¯¼çš„å®šè¯­ä»å¥\nwhen where why\n3ã€çŠ¶è¯­ä»å¥\nä¿®é¥°åŠ¨ä½œçš„å‘ç”Ÿçš„æ—¶é—´ã€åœ°ç‚¹ã€åŸå› ã€æ–¹å¼\nä¹å¤§çŠ¶è¯­ä»å¥\n1ã€æ—¶é—´çŠ¶è¯­ä»å¥\nå¸¸ç”¨å¼•å¯¼è¯ï¼šwhen, as, while, as soon as, before, after, since , till, until\nç‰¹æ®Šå¼•å¯¼è¯ï¼šthe minute, the moment, the second, every time, the dayï¼Œthe instant,\nI was fat when I was a child.\n2ã€åœ°ç‚¹çŠ¶è¯­ä»å¥\nå¸¸ç”¨å¼•å¯¼è¯ï¼šwhere\nç‰¹æ®Šå¼•å¯¼è¯ï¼šwherever, anywhere, everywhere\nKeep it where you can see it.\n3ã€åŸå› çŠ¶è¯­ä»å¥\nå¸¸ç”¨å¼•å¯¼è¯ï¼šbecause, since, as, for\nç‰¹æ®Šå¼•å¯¼è¯ï¼šseeing that, now that, in that, considering that, given that.\nMy friends dislike me because Iâ€™m beautiful .\n4ã€ç›®çš„çŠ¶è¯­ä»å¥\nå¸¸ç”¨å¼•å¯¼è¯ï¼šso that, in order that\nç‰¹æ®Šå¼•å¯¼è¯ï¼šlest, in case, for fear thatï¼Œin the hope that, for the purpose that, to the end that\nstudy hard so that you can pass the exam.\n5ã€ç»“æœçŠ¶è¯­ä»å¥\nå¸¸ç”¨å¼•å¯¼è¯ï¼šso â€¦ that, soâ€¦ that, such â€¦ that,\nç‰¹æ®Šå¼•å¯¼è¯ï¼šsuch that, to the degree that, to the extent that, to such a degree that,\nHe got up so early that he caught the first bus.\n6ã€æ¡ä»¶çŠ¶è¯­ä»å¥\nå¸¸ç”¨å¼•å¯¼è¯ï¼šif, unless,\nç‰¹æ®Šå¼•å¯¼è¯ï¼šas/so long as, only if, providing/provided that, supposing that, in case that, on condition that\nIf you ask him, he will help you.\n7ã€æ–¹å¼çŠ¶è¯­ä»å¥\nå¸¸ç”¨å¼•å¯¼è¯ï¼šas, as if, how\nç‰¹æ®Šå¼•å¯¼è¯ï¼šthe way\nThink as i think\n8ã€æ¯”è¾ƒçŠ¶è¯­ä»å¥\nå¸¸ç”¨å¼•å¯¼è¯ï¼šas(åŒçº§æ¯”è¾ƒ), than(ä¸åŒç¨‹åº¦çš„æ¯”è¾ƒ)\nç‰¹æ®Šå¼•å¯¼è¯ï¼šthe more â€¦ the more â€¦ ; just as â€¦ï¼Œ soâ€¦; A is to B what /as X is to Y; no â€¦ more than; not A so much as B\nThe house is three times as big as ours.\n9ã€è®©æ­¥çŠ¶è¯­ä»å¥\nå¸¸ç”¨å¼•å¯¼è¯ï¼šthough, although, even if, even though\nç‰¹æ®Šå¼•å¯¼è¯ï¼š as(ç”¨åœ¨è®©æ­¥çŠ¶è¯­ä»å¥ä¸­å¿…é¡»è¦å€’è£…)ï¼Œwhile ( ä¸€èˆ¬ç”¨åœ¨å¥é¦– )ï¼Œno matter â€¦ï¼Œ in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever\nThough I believe it, yet I must consider.\nå››.ç‰¹æ®Šå¥å¼ 1ã€å¼ºè°ƒå¥\nIt is ï¼ˆåè¯ / ä»‹å®¾ï¼‰æŒ‡çš„æ˜¯è¢«å¼ºè°ƒçš„å†…å®¹that ï¼ˆ\u0026hellip;\u0026hellip;..ï¼‰\nIt was she whom we are talking about.\n2ã€å€’è£…å¥\næ­£å¸¸å¥åº ï¼šä¸»è°“å®¾\nå€’è£…å¥åº ï¼šè°“ä¸»å®¾\nwe can win only through hard work .\nonly through hard work can we win .\n3ã€è™šæ‹Ÿè¯­æ°”ï¼Œå‡è®¾ä¸å¯èƒ½å‘ç”Ÿçš„äº‹æƒ…\n1ã€å¯¹è¿‡å»æƒ…å†µçš„è™šæ‹Ÿ\nä»å¥ç”¨ had done\nä¸»å¥ç”¨ would could might should have done\n2ã€å¯¹ç°åœ¨æƒ…å†µçš„è™šæ‹Ÿ\nä»å¥ç”¨ did , waså˜æˆwere\nä¸»å¥ç”¨ would could might should do\n3ã€å¯¹å°†æ¥æƒ…å†µè™šæ‹Ÿ\nä»å¥ç”¨ did ï¼Œwas å˜æˆ wereï¼Œshould do,were to do\nä¸»å¥ç”¨ would could might should do\näº”.ç±»å‹ é™ˆè¿°å¥\ni like English very much . æˆ‘éå¸¸å–œæ¬¢è‹±è¯­ã€‚\nç–‘é—®å¥\nis this your key ? è¿™æ˜¯ä½ çš„é’¥åŒ™å—ï¼Ÿ\nç¥ˆä½¿å¥\nä¸€ç§æ˜¯ä»¥åŠ¨è¯åŸå½¢å¼€å¤´ï¼Œåœ¨åŠ¨è¯åŸå½¢ä¹‹å‰åŠ do (ä½†åªé™äºçœç•¥ç¬¬äºŒäººç§°ä¸»è¯­çš„å¥å­)ã€‚\nmind you head å°å¿ƒç¢°å¤´ï¼\nç¬¬äºŒç§ç¥ˆä½¿å¥ä»¥letå¼€å¤´\nLet\u0026rsquo;s have another try\næ„Ÿå¹å¥\nwhat a brave girl ! çœŸæ˜¯ä¸ªå‹‡æ•¢çš„å¥³å­©å­\nhttps://zhuanlan.zhihu.com/p/400448345\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E4%B8%80/","summary":"\u003ch2 id=\"ä¸€ç®€å•å¥å­åˆ†æ\"\u003eä¸€.ç®€å•å¥å­åˆ†æ\u003c/h2\u003e\n\u003cp\u003eâ€‚\u003cstrong\u003eè‹±è¯­å¥å­= ä¸»å¹²+ä¿®é¥°æˆåˆ†\u003c/strong\u003e\nâ€‚åˆ†æå¥å­ç»“æ„:\nâ€ƒâ€ƒä¸€ä¸ªä¸­å¿ƒ + ä¸¤ä¸ªè¦ç‚¹\nâ€ƒâ€ƒä¸€ä¸ªä¸­å¿ƒ: åŠ¨è¯. å¥å­å¿…é¡»å³åŠ¨è¯\nâ€ƒâ€ƒä¸¤ä¸ªè¦ç‚¹: ä¸»è¯­ + è°“è¯­. è°“è¯­æ˜¯åŠ¨è¯,ä¸»è¯­ä¸ºåŠ¨ä½œçš„æ‰§è¡Œè€…æˆ–æ¥å—è€….\nâ€ƒâ€ƒ\u003cstrong\u003eå¥å­çš„æ ¸å¿ƒæ˜¯ä¸»è°“ç»“æ„\u003c/strong\u003e\u003c/p\u003e","title":"è‹±è¯­è¯­æ³•ä¸€"},{"content":"hugoè¿è¡Œ hugo -F --cleanDestinationDir # æœ¬åœ°é¢„è§ˆ hugo server å‚è€ƒé“¾æ¥ï¼š\nhttps://www.sulvblog.cn/\nhttps://www.jianshu.com/p/fa95c0c1fdab\nhttps://lishensuo.github.io/\nhttps://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612\nhttps://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38\nhttps://blog.csdn.net/qq_45975757/article/details/108923612\nmongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo äº‘å‡½æ•°è¿è¡Œæ­£å¸¸ï¼Œè¯·å‚è€ƒ https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 å®Œæˆå‰ç«¯çš„é…ç½®\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;1.6.7\u0026#34;} æ‰˜ç®¡ ä¸ºäº†æé«˜è®¿é—®é€Ÿåº¦æ‰˜ç®¡åœ¨giteeä¸Šï¼Œè¿ç§»å®Œæˆåå°†ä¼šåŒæ—¶æ‰˜ç®¡åˆ°githubä¸­ã€‚ é€šè¿‡ä¸åŒåˆ†æ”¯ä¿å­˜æºç å’Œé™æ€ç½‘é¡µå†…å®¹ï¼Œç”¨br_hugoç®¡ç†æºç ï¼Œmasteråˆ†æ”¯ç®¡ç†public\nhexo # æ¸…ç†ç¼“å­˜ hexo clean # ç”Ÿæˆç½‘é¡µ hexo g # å¯åŠ¨æœ¬åœ°æœåŠ¡ç«¯å£ hexo s # å‘å¸ƒåˆ°github hexo d # å¼ºåˆ¶æ¨é€å¤‡ä»½æºç åˆ†æ”¯ git push -f origin backup GitHub Pages + Hexoä½¿ç”¨åŠé…ç½® githubä¸Šåˆ›å»ºä¸€ä¸ª username.github.io çš„å·¥ç¨‹ï¼Œusername å¿…é¡»ä¸ºgithubçš„ç”¨æˆ·å\nå‚è€ƒé“¾æ¥ https://www.jianshu.com/p/f82c76b90336\nhttps://www.jianshu.com/p/5d0b31032d55\nhttps://blog.csdn.net/weixin_41922289/article/details/95639870\nhttps://theme-next.org/\nhttps://hexo.io/zh-cn/docs/\nhttps://www.jianshu.com/p/3a05351a37dc\nhttps://www.zhyong.cn/posts/ca02/\nhttp://theme-next.iissnan.com/\nhttps://liam.page/\nhttps://liam.page/en/\nHexoåšå®¢æ·»åŠ helper-live2dåŠ¨æ€æ¨¡å‹æ’ä»¶ https://blog.csdn.net/qq_30930805/article/details/ ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/blog/","summary":"hugoè¿è¡Œ hugo -F --cleanDestinationDir # æœ¬åœ°é¢„è§ˆ hugo server å‚è€ƒé“¾æ¥ï¼š https://www.sulvblog.cn/ https://www.jianshu.com/p/fa95c0c1fdab https://lishensuo.github.io/ https://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612 https://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38 https://blog.csdn.net/qq_45975757/article/details/108923612 mongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo äº‘å‡½æ•°è¿è¡Œæ­£å¸¸ï¼Œè¯·å‚è€ƒ https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 å®Œæˆå‰ç«¯çš„é…ç½®\u0026#34;,\u0026#34;version\u0026#3","title":"hexo-\u003ehugoè¿ç§»"},{"content":"ubuntu æ¢æº # å¤‡ä»½ cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade å‚è€ƒé“¾æ¥ï¼š ubuntu20.04æ›´æ”¹å›½å†…é•œåƒæº https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334\nå®‰è£…æœç‹—è¾“å…¥æ³• https://blog.csdn.net/Mr_Sudo/article/details/124874239\nubuntu æ˜¾ç¤º https://ubuntuqa.com/article/8837.html\nhttps://www.csdn.net/tags/MtTaAgzsNjg5MTk4LWJsb2cO0O0O.html\nUbunut 22.04 LTS ç‰ˆæœ¬ GNU/Linuxæ ¸å¿ƒ\nGCC 11.2.0 binutils 2.38 glibc 2.35 ç¼–è¯‘å·¥å…·é“¾\nPython 3.10.4 Perl 5.34.0 LLVM 14 golang 1.18 rustc 1.58 OpenJDK Ruby 3.0 systemd 249.11 OpenSSL 3.0 è™šæ‹ŸåŒ–\nqemu 6.2.0 libvirt 8.0.0 virt-manager 4.0.0 LinuxåŒ…ç®¡ç† snap flameshotæˆªå›¾å·¥å…· # å¿«æ·æ–¹å¼ flameshot gui https://www.cnblogs.com/kendoziyu/p/how_to_screenshot_in_ubuntu2004.html ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxtool/","summary":"ubuntu æ¢æº # å¤‡ä»½ cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade å‚è€ƒé“¾æ¥ï¼š ubuntu20.04æ›´æ”¹å›½å†…é•œåƒæº https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334 å®‰è£…æœç‹—è¾“å…¥æ³• https://blog.csdn.net/Mr_Sudo/article/details/124874239 ubuntu æ˜¾ç¤º https://ubuntuqa.com/article/8837.html https://www.csdn.net/tags/MtTaAgzsNjg5MTk4LWJsb2cO0O0O.html Ubunut 22.04 LTS ç‰ˆæœ¬ GNU/Lin","title":"linuxTool"},{"content":"Vim vimå¿«æ·æ–¹å¼ # ç¼–è¾‘æ¨¡å¼ i a o # i è¿›å…¥ç¼–è¾‘æ¨¡å¼ # é€€å‡ºESC è¿”å›å‘½ä»¤æ¨¡å¼ # ä¿å­˜é€€å‡º wq # æ”¾å¼ƒé€€å‡º !q # å›åˆ°æ–‡ä»¶é¦–éƒ¨ gg # åˆ°æ–‡ä»¶å°¾éƒ¨ GG # æŸ¥æ‰¾ / # ç²˜è´´ p # å²ä¸Šæœ€å…¨çš„vimå¿«æ·é”® Vimä½¿ç”¨ç¬”è®° Windowsä½¿ç”¨Vim åœ¨Windowsç³»ç»Ÿä¸­ï¼Œå®‰è£…gitåå·²ç»å­˜åœ¨vimï¼Œæ‰¾åˆ°vim.exeæ‰€åœ¨ç›®å½•ï¼Œæ·»åŠ åˆ°ç¯å¢ƒå˜é‡pathä¸­å³å¯ã€‚ Windowsä¸‹è½½ Vimå®‰è£… å‚è€ƒåšå®¢ï¼šåœ¨Windowsä¸‹å®‰è£…å’Œä½¿ç”¨vim PowerVim PowerVimå¿«æ·é”® ;nÂ # æ‰“å¼€æ–‡ä»¶ç›®å½•æ ‘æ˜¾ç¤ºåœ¨å±å¹•å·¦ä¾§ ;mÂ # æ‰“å¼€å½“å‰å‡½æ•°å’Œå˜é‡ç›®å½•æ ‘æ˜¾ç¤ºåœ¨å±å¹•å³ä¾§ ;wÂ # ä¿å­˜æ–‡ä»¶ ;uÂ # å‘ä¸Šç¿»åŠå± ;dÂ # å‘ä¸‹ç¿»åŠå± ;1Â # å…‰æ ‡å¿«é€Ÿç§»åŠ¨åˆ°è¡Œé¦– ;2Â # å…‰æ ‡å¿«é€Ÿç§»åŠ¨åˆ°è¡Œæœ« ;aÂ # å¿«é€Ÿåˆ‡æ¢.hå’Œcppæ–‡ä»¶ï¼Œå†™C++çš„æ—¶å€™å¾ˆæ–¹ä¾¿ ;eÂ # æ‰“å¼€ä¸€ä¸ªæ–°æ–‡ä»¶ ;zÂ # åˆ‡å›shelläº¤äº’å‘½ä»¤ï¼Œè¾“å…¥fgåœ¨åˆ‡å›vimï¼Œéå¸¸å®ç”¨ ;sÂ # æ°´å¹³åˆ†å±ï¼Œå¹¶æ‰“å¼€æ–‡ä»¶ç›®å½•é€‰å–æƒ³æ‰“å¼€çš„æ–‡ä»¶ï¼Œå¦‚æœæƒ³æ–°å»ºæ–‡ä»¶ï¼Œ;e å°±å¥½ ;vÂ # ç«–ç›´åˆ†å±ï¼Œå¹¶æ‰“å¼€æ–‡ä»¶ç›®å½•é€‰å–æƒ³æ‰“å¼€çš„æ–‡ä»¶ï¼Œå¦‚æœæƒ³æ–°å»ºæ–‡ä»¶ï¼Œ;e å°±å¥½ ;fwÂ # æŸ¥æ‰¾é¡¹ç›®å†…å…³é”®å­— ;ffÂ # æŸ¥æ‰¾é¡¹ç›®å†…æ–‡ä»¶å ;gtÂ # è·³è½¬åˆ°å˜é‡æˆ–è€…å‡½æ•°å®šä¹‰çš„åœ°æ–¹ï¼Œå‰ææ˜¯å®‰è£…ctagsï¼Œå¹¶ä¸”åœ¨åœ¨PowerVimè¾“å…¥ ;tgå‘½ä»¤ Jump to the definition of the keyword where the cursor is located, but make sure you have make ctags ;grÂ # è·³å›ï¼Œå¯¹åº”ç€;gt ;tgÂ # å¯¹å½“å‰ç›®å½•æ‰“ctag ;yÂ # ä¿å­˜å½“å‰é€‰ä¸­çš„ç›®å½•åˆ°ç³»ç»Ÿå‰ªåˆ‡æ¿ï¼Œå‰ææ˜¯vimæ”¯æŒç³»ç»Ÿå‰ªåˆ‡æ¿çš„å¯„å­˜å™¨ dsfa;w ;h/l/k/j # å…‰æ ‡å‘å·¦å³ä¸Šä¸‹çª—å£ç§»åŠ¨ï¼Œç‰¹åˆ«æ˜¯æ‰“å¼€å¤šä¸ªçª—å£ã€‚ä½¿ç”¨è¿™ä¸ªå¿«æ·é”®ç»„åˆéå¸¸å®ç”¨ ;ggÂ # æŒ‰é¡ºåºå…‰æ ‡è·³è½¬å„ä¸ªçª—å£ # Shortcuts without ; eÂ # å¿«é€Ÿåˆ é™¤å…‰æ ‡æ‰€åœ¨çš„è¯ tabcÂ # å…³é—­å½“å‰tabï¼Œå¯ä»¥ç”¨:tabnewæ¥æ‰“å¼€ä¸€ä¸ªæ–°çš„tab Close tab, of course you should :tabnew a file first. F1Â # ç¼–è¯‘C++ä»£ç ï¼Œè‡ªå·±å†™çš„C++ä¾‹å­çš„æ—¶å€™ä¸€é”®ç¼–è¯‘ã€‚å‰ææ‰‹åŠ¨åœ¨å½“å‰ç›®å½•å»ºä¸€ä¸ªbinæ–‡ä»¶å¤¹ï¼Œè¿™æ˜¯ç”¨æ¥å­˜æ”¾ç¼–è¯‘äº§ç”Ÿçš„æ‰§è¡Œæ–‡ä»¶ gcÂ # å¿«é€Ÿæ³¨é‡Šé€‰ä¸­çš„å—ï¼ˆæ˜¯visualæ¨¡å¼ä¸‹é€‰ä¸­çš„å—ï¼‰ gccÂ # å¿«é€Ÿå½“å‰è¡Œ {Â # å…‰æ ‡å‘ä¸Šç§»åŠ¨ä¸€ä¸ªä»£ç å—s }Â # å…‰æ ‡å‘ä¸‹ç§»åŠ¨ä¸€ä¸ªä»£ç å— PowerVimå®‰è£…åŠé…ç½® ã€VIMã€‘PowerVimå®‰è£…åŠä½¿ç”¨\nPowerVim - ä½¿Vimæ›´åŠ å¼ºå¤§æ˜“ç”¨\nå®‰è£…PowerVim é—®é¢˜è§£å†³è¿‡ç¨‹è®°å½•\nctags ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/vim/","summary":"Vim vimå¿«æ·æ–¹å¼ # ç¼–è¾‘æ¨¡å¼ i a o # i è¿›å…¥ç¼–è¾‘æ¨¡å¼ # é€€å‡ºESC è¿”å›å‘½ä»¤æ¨¡å¼ # ä¿å­˜é€€å‡º wq # æ”¾å¼ƒé€€å‡º !q # å›åˆ°æ–‡ä»¶é¦–éƒ¨ gg # åˆ°æ–‡ä»¶å°¾éƒ¨ GG # æŸ¥æ‰¾ / # ç²˜è´´","title":"vim"},{"content":"windows å·¥å…·è½¯ä»¶ Snipaste æˆªå›¾è½¯ä»¶ æ”¯æŒè‡ªå®šä¹‰è®¾ç½®å¿«æ·é”® Download\nZoomIt å±å¹•ç¼©æ”¾ã€æ ‡è®°ã€å½•åˆ¶ å±•ç¤ºå°å·¥å…· whois å±…ç„¶å¯ä»¥åœ¨Windowsä½¿ç”¨ Download\nSysinternals å·¥å…·é›† Download\neveryting å¿«é€ŸæŸ¥æ‰¾æ–‡ä»¶ Download\n7zip å¼€æºå‹ç¼©è½¯ä»¶ Download\nWiztree ç£ç›˜æ–‡ä»¶å ç”¨ Download\nWindows Terminal å–ä»£ä¼ ç»Ÿcmdæ˜¾ç¤ºï¼Œå¯é›†æˆPowerShellï¼Œ ç™»å½•wslï¼Œ æœªæ¥Windowså°†è®¾ç½®ä¸ºé»˜è®¤ç»ˆç«¯ å¾®è½¯å•†åº—\nPowerShell ä¸€æ¬¾shellï¼Œæ”¯æŒWindowsã€linuxã€macï¼Œæ¨èWindowsç»“åˆ Windows Terminalä½¿ç”¨, ä½¿WindowsåƒLinuxç»ˆç«¯ä¸€æ ·çˆ½ Download\nwinget search Microsoft.PowerShell winget install Microsoft.PowerShell å‚è€ƒé“¾æ¥ï¼š\nWindows Powershellå’ŒWindows Terminalçš„åŒºåˆ«\nå®‰è£…å’Œè®¾ç½® Windows ç»ˆç«¯\nQ-Dir å¤šçª—å£èµ„æºç®¡ç†å™¨ Download\nFileZilla å¤šåè®®æ–‡ä»¶ä¼ é€ï¼Œæ”¯æŒFTPã€SFTPï¼ŒåŒ…å«Clientå’ŒServerï¼Œæ”¯æŒWindowsã€Linuxã€mac Download\nç»ˆç«¯è¿æ¥ç¨‹åº secureCRT éœ€è¦ç ´è§£ https://blog.csdn.net/qq_39052513/article/details/104692026\nvscode vscode ä¸Šä¼ å›¾ç‰‡ # ä¸Šä¼ å‰ªè´´æ¿ä¸­çš„å›¾ç‰‡åˆ°æœåŠ¡å™¨ã€‚ ctrl + alt + u # æ‰“å¼€æ–‡ä»¶æµè§ˆå™¨é€‰æ‹©å›¾ç‰‡ä¸Šä¼ ã€‚ ctrl + alt + e https://www.jianshu.com/p/868b3a2028f8 https://zhuanlan.zhihu.com/p/131584831 WindowsåŒ…ç®¡ç† Scoop Scoop æ˜¯ Windows çš„å‘½ä»¤è¡Œå®‰è£…ç¨‹åºï¼Œæ˜¯ä¸€ä¸ªå¼ºå¤§çš„åŒ…ç®¡ç†å·¥å…·\né¡¹ç›®åœ°å€\nä½¿ç”¨æ•™ç¨‹\nChocolatey choro Windowsè½¯ä»¶ç®¡ç†å·¥å…·Chocolateyçš„å®‰è£…å’Œä½¿ç”¨\nwinget å®˜æ–¹æ¨å‡º è°ç”¨Windows ç»ˆç«¯å®‰è£…ç¨‹åºï¼Ÿ æˆ‘ï¼\n# ä½¿ç”¨ WinGet å®‰è£…ä¸€é winget install postman winget search postman # å¸è½½ï¼Œå†ç”¨ Scoop å®‰è£…ä¸€é scoop install postman vcpkg C/C++ åº“ç®¡ç†å·¥å…·ï¼Œè·¨å¹³å° Get started with vcpkg\ncget https://cget.readthedocs.io/en/latest/#\nå¼€æºåº“é›†æˆå™¨Vcpkgå…¨æ•™ç¨‹\nWSL å®‰è£…ubuntu20.04 å®‰è£…åˆ°éç³»ç»Ÿç›˜ç›®å½•ï¼Œä¸‹è½½ç¦»çº¿å®‰è£…åŒ…ï¼Œå¤åˆ¶åˆ°æƒ³è¦å®‰è£…çš„ç›®å½•ä¸‹ï¼Œè§£å‹ï¼Œä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œubuntu2004.exe\nå¸è½½wsl wslconfig /l # ä»åˆ—è¡¨ä¸­é€‰æ‹©è¦å¸è½½çš„å‘è¡Œç‰ˆï¼ˆä¾‹å¦‚Ubuntuï¼‰å¹¶é”®å…¥å‘½ä»¤ wslconfig /u Ubuntu å‚è€ƒé“¾æ¥ï¼šWSLç³»åˆ—æ“ä½œï¼šå®‰è£…ï¼Œå¸è½½\nè®¾ç½®wsl # æ›´æ”¹é»˜è®¤rootç”¨æˆ·ç™»å½• ubuntu1804.exe config --default-user root # æ›´æ”¹é»˜è®¤ç™»é™†ç›®å½• # list ä¸­ Ubuntu-20.04 æ¡ç›®ä¸­æ·»åŠ  \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu-20.04\u0026#34; # ä»¥ç®¡ç†å‘˜æƒé™è¿è¡Œcmd # åœæ­¢ net stop LxssManager # å¯åŠ¨ net start LxssManager å›¾åºŠ https://blog.csdn.net/qq_44314954/article/details/122951033\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;æœªæ•´ç†éƒ¨åˆ†\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nrustdesk è¿œç¨‹å¼€æºè½¯ä»¶\nmaya\nimagine\nscreentogif\nditto\nbleachbit\nqbittorrent\ngrammarly\npotplayer https://iptv-org.github.io/iptv/index.m3u\nå‰ªåˆ‡æ¿win10è‡ªå¸¦çš„æœ‰å¾ˆå¤šå‰ªåˆ‡è®°å½•çš„å¿«æ·é”®Windowsé”®â•Vé”®\nçº¿ä¸Šæ€ç»´å¯¼å›¾ https://gitmind.cn/app/template åœ¨çº¿æ–‡æ¡£è½¬æ¢ https://www.aconvert.com/cn/ å¼€æºè½¯ä»¶ä¸‹è½½ç½‘ç«™ https://www.fosshub.com/#\nwindows ternial æ·»åŠ  git base åˆ°ternial chromeæ’ä»¶ æ²¹çŒ´\nwindowsè¾“å…¥è‹±æ–‡ä¸­é—´æœ‰é—´éš™ è¿›å…¥äº†å…¨è§’æ¨¡å¼ï¼Œé€‰æ‹©åŠè§’å³å¯\nReact Router http://react-guide.github.io/react-router-cn/index.html\nyoutube ä¸‹è½½ https://www.ganbey.com/youtube-download-3774\nzlog https://blog.csdn.net/twd_1991/article/details/80481920\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\ngdb https://leetcode-cn.com/circle/article/7mxorv\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/windowssoftware/","summary":"windows å·¥å…·è½¯ä»¶ Snipaste æˆªå›¾è½¯ä»¶ æ”¯æŒè‡ªå®šä¹‰è®¾ç½®å¿«æ·é”® Download ZoomIt å±å¹•ç¼©æ”¾ã€æ ‡è®°ã€å½•åˆ¶ å±•ç¤ºå°å·¥å…· whois å±…ç„¶å¯ä»¥åœ¨Windowsä½¿ç”¨ Download Sysinternals å·¥å…·é›† Download everyting å¿«é€ŸæŸ¥æ‰¾æ–‡ä»¶ Download 7zip å¼€æºå‹","title":"WindowsSoftware"},{"content":"å¯åŠ¨Uç›˜åˆ¶ä½œ ä¸‹è½½é•œåƒ Ubuntu é•œåƒ Ubuntu 20.04\u0026amp;22.04\nWindows\né•œåƒçƒ§å½•å·¥å…· è½¯ç¢Ÿé€šUltraISO å†™å…¥é•œåƒï¼Œæ ‘è“æ´¾åˆ·é•œåƒ\nVentoy å®˜æ–¹ç½‘ç«™ Ventoyæ”¯æŒå¤šä¸ªISOé•œåƒï¼Œå¼€æºï¼Œæ”¯æŒLinuxå’ŒWindows ventoyè¯¦ç»†ä½¿ç”¨æ•™ç¨‹ åˆ¶ä½œå®Œå¯åŠ¨ç›˜ï¼Œå°†ISOå¤åˆ¶åˆ°Uç›˜å³å¯\nWinPE æ”¯æŒå¤šé•œåƒ æ”¯æŒå¤šé•œåƒ\nå®‰è£…ç³»ç»Ÿ å°ç±³ F2è®¾ç½®bootå¯†ç ï¼Œé‡å¯F12å®‰è£…Ubuntu\nThinkpad 1.å…³é—­bitlocker 2.f1è¿›å…¥bioså…³é—­security boot 3.f12è¿›å…¥bootï¼Œé€‰æ‹©å¯åŠ¨Uç›˜\nQ\u0026amp;A ä»€ä¹ˆåŠŸèƒ½Windowsä¸Šæœ‰ï¼Œåœ¨Linuxæ²¡æœ‰åˆæ²¡æœ‰æ›¿ä»£æ–¹æ³• ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","summary":"å¯åŠ¨Uç›˜åˆ¶ä½œ ä¸‹è½½é•œåƒ Ubuntu é•œåƒ Ubuntu 20.04\u0026amp;22.04 Windows é•œåƒçƒ§å½•å·¥å…· è½¯ç¢Ÿé€šUltraISO å†™å…¥é•œåƒï¼Œæ ‘è“æ´¾åˆ·é•œåƒ Ventoy å®˜æ–¹ç½‘ç«™ Ventoyæ”¯æŒå¤šä¸ªISOé•œåƒï¼Œå¼€æºï¼Œæ”¯æŒ","title":"ç³»ç»Ÿå®‰è£…"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/read/movie/movie/","summary":"","title":"Movie"},{"content":" QMD ã€Šå¦‚æ„¿ã€‹-ç‹è² å¤©åä¾ç„¶\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/music/music/","summary":"QMD ã€Šå¦‚æ„¿ã€‹-ç‹è² å¤©åä¾ç„¶","title":"Music"},{"content":"è½¯ä»¶æ•…äº‹ 1946å¹´ ENIAC\næ‰¹å¤„ç†ç³»ç»Ÿ ç¡¬ä»¶å‘å±•-ã€‹ åˆ†æ—¶ç³»ç»Ÿ æœºå™¨è¯­è¨€\u0026ndash;çº¸å¸¦ æ±‡ç¼–è¯­è¨€\u0026ndash; æŒ‡ä»¤ æ“ä½œ Fortranè¯­è¨€ - ç¬¬ä¸€ç§é«˜çº§è®¡ç®—æœºè¯­è¨€ COBOL è¯­è¨€ BASIC\nå¡è€åŸº \u0026ndash; äººå·¥æ™ºèƒ½\nIBM 701 704(Fortranå•†ç”¨) IBM OS/360\nå­˜å‚¨æ—¶è®¡ç®—æœº\nUnix c è¯­è¨€\næ¬§æ´²è®¡ç®—æœºæŠ€æœ¯ï¼š linux èŠ¬å…° ä¸‡ç»´ç½‘ ç‘å…¸\nAPPLE II Macish\nå¾®è½¯ æ”¶è´­DOS\nwindows BASIC\né¼ æ ‡ã€ æ˜¾ç¤ºå™¨\nC++\nJava Javaä¸äº’è”ç½‘\né˜¿å¸•å¥‡ IBM linux\nç¡…è°·ç™¾å¹´ ç¡…è°· æ–¯å¦ç¦ã€ä¼¯å…‹åˆ©ã€åœ£ä½•å¡å¤§å­¦\nç‰¹æ›¼\nçœŸç©ºç®¡ã€æ™¶ä½“ç®¡ã€é›†æˆç”µè·¯ ä»™ç«¥åŠå¯¼ä½“ - å…«å›å¾’ è‹±ç‰¹å°”ã€AMDã€è‹±ä¼Ÿè¾¾\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/computerbook/","summary":"\u003ch2 id=\"è½¯ä»¶æ•…äº‹\"\u003eè½¯ä»¶æ•…äº‹\u003c/h2\u003e\n\u003cp\u003e1946å¹´ ENIAC\u003c/p\u003e\n\u003cp\u003eæ‰¹å¤„ç†ç³»ç»Ÿ\nç¡¬ä»¶å‘å±•-ã€‹ åˆ†æ—¶ç³»ç»Ÿ\næœºå™¨è¯­è¨€\u0026ndash;çº¸å¸¦\næ±‡ç¼–è¯­è¨€\u0026ndash; æŒ‡ä»¤ æ“ä½œ\nFortranè¯­è¨€ - ç¬¬ä¸€ç§é«˜çº§è®¡ç®—æœºè¯­è¨€\nCOBOL è¯­è¨€\nBASIC\u003c/p\u003e","title":"computerbook"},{"content":"ã€ŠLesson from the Edgeã€‹ æ¥è‡ªè¾¹ç¼˜çš„æ•™è®­\u0026ndash;çº¦ç“¦è¯ºç»´å¥‡ å‰USAé©»ä¹Œå…‹å…°å¤§ä½¿\nã€Šå±€å¤–äººã€‹ åŠ ç¼ª ä¸ªäººä¸»ä¹‰ï¼Œæ— çŸ¥æ˜¯æœ€å¤§çš„é‚ªæ¶ ã€Šculture evolutionã€‹ æ–‡åŒ–çš„æ¼”è¿› ronald inglehartæ•™æˆ ä»€ä¹ˆåŸå› çŒå‘ä¸ªäººä¸»ä¹‰\nã€Šç»“æ„æ€§æ€ç»´ã€‹\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/readingplan/","summary":"ã€ŠLesson from the Edgeã€‹ æ¥è‡ªè¾¹ç¼˜çš„æ•™è®­\u0026ndash;çº¦ç“¦è¯ºç»´å¥‡ å‰USAé©»ä¹Œå…‹å…°å¤§ä½¿ ã€Šå±€å¤–äººã€‹ åŠ ç¼ª ä¸ªäººä¸»ä¹‰ï¼Œæ— çŸ¥æ˜¯æœ€å¤§çš„é‚ªæ¶ ã€Šcultur","title":"Reading Plan"},{"content":"è±†è±†ä¸‰éƒ¨æ›² ã€ŠèƒŒå›ã€‹ ã€Šé¥è¿œçš„æ•‘ä¸–ä¸»ã€‹ ã€Šå¤©å¹•çº¢å°˜ã€‹\nåœ¨ç»†é›¨ä¸­å‘¼å”¤ ä½™å æ™®é€šå†œæ‘å°‘å¹´ä»¥æ—è§‚è€…è§’åº¦å™è¿°è‡ªå·±çš„ç«¥å¹´å°‘å¹´æˆé•¿ï¼Œä¸–é—´äººéƒ½å¤„äºä¸€è¾†æ—¶å…‰åˆ—è½¦ä¸­ï¼Œå…¶ä¸­é‡åˆ°çš„äººå’Œäº‹ï¼Œä¸ç®¡ä»–ä»¬æ˜¯å¥½çš„è¿˜æ˜¯åçš„ï¼Œæœªæ¥çš„æœªçŸ¥éƒ½æ— å¯é€ƒé¿ï¼Œå”¯ä¸€èƒ½åšå¥½çš„å°±æ˜¯ï¼šå¥½å¥½æ´»ç€ï¼Œçæƒœçœ¼å‰çš„ä¸€åˆ‡ï¼Œåšæœ€å¥½çš„è‡ªå·±ã€‚\næ­»äº¡ä¸æ˜¯å¤±å»ç”Ÿå‘½ï¼Œåªæ˜¯èµ°å‡ºäº†æ—¶é—´\né€šå¾€å¥´å½¹ä¹‹è·¯ å¦‚æœæˆ‘ä»¬ä»…ä»…åªæ˜¯ä¸€éƒ¨æ— äººæ€§çš„æœºå™¨ä¸­çš„ä¸€ä¸ªé½¿è½®ï¼Œè¿™ä¹Ÿè®¸ä¸æ˜¯å¥½äº‹æƒ…ï¼›ä½†å¦‚æœæˆ‘ä»¬å†ä¹Ÿæ— æ³•è„±ç¦»å®ƒï¼Œè¢«æŸç¼šåœ¨ä¸ºæˆ‘ä»¬é€‰å®šçš„é‚£äº›ä¸Šçº§çš„èº«è¾¹ï¼Œé‚£ä¹ˆæƒ…å†µå°±ä¸çŸ¥é“è¦ç³Ÿç³•å¤šå°‘å€ã€‚å½“æ¯ä¸ªäººæ„è¯†åˆ°ä»–çš„å‘½è¿çš„ä¸æ»¡ï¼Œå°±ä¼šåŒä»–çš„è¿™ç§æ„è¯†ä¸€èµ·æˆé•¿ã€‚\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/read/","summary":"è±†è±†ä¸‰éƒ¨æ›² ã€ŠèƒŒå›ã€‹ ã€Šé¥è¿œçš„æ•‘ä¸–ä¸»ã€‹ ã€Šå¤©å¹•çº¢å°˜ã€‹ åœ¨ç»†é›¨ä¸­å‘¼å”¤ ä½™å æ™®é€šå†œæ‘å°‘å¹´ä»¥æ—è§‚è€…è§’åº¦å™è¿°è‡ªå·±çš„ç«¥å¹´å°‘å¹´æˆé•¿ï¼Œä¸–é—´äººéƒ½å¤„äºä¸€è¾†æ—¶å…‰åˆ—è½¦ä¸­ï¼Œå…¶","title":"è¯»ä¹¦"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/read/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/","summary":"","title":"é—²è¨€ç¢è¯­"},{"content":"æ€»ç»“ leetcodeåŸºç¡€é¢˜ç›® ç»å…¸é¢˜ç›®ï¼š 3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² 4. 6. 7. 8. 9. 11. 12. 13. 21. 24. 28. 38. 53. 66. 82. 94. 104. 108. 109. 110. 112. 121. 136. 142. 160. 169. 173. 189. 201. 203. 206. 217. 226. 231. 234. 367. 389. 442. 476. 617. 701. 938. 1089. 1207.\n1.ä¸¤æ•°ä¹‹å’Œ æ€è·¯ï¼šä¸¤å±‚éå†\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) { int i, j; int *ret = (int *)malloc(sizeof(int) * 2); for (i = 0; i \u0026lt; numsSize; i++) { int key = target - nums[i]; for (j = i + 1; j \u0026lt; numsSize; j++) { if (nums[j] == key) { ret[0] = i; ret[1] = j; } } } *returnSize = 2; return ret; } 2.ä¸¤æ•°ç›¸åŠ  æ€è·¯ï¼šä¸¤ä¸ªé“¾è¡¨ï¼Œåˆ¤æ–­é“¾è¡¨æ˜¯å¦ä¸ºç©ºorï¼Œæ±‚å’Œä¸ä¸ºç©ºé“¾è¡¨èŠ‚ç‚¹å€¼ï¼Œç¬¬ä¸€æ¬¡æ·»åŠ å¤´èŠ‚ç‚¹ï¼Œä¹‹åæ·»åŠ åˆ°å°¾èŠ‚ç‚¹ï¼Œæ³¨æ„å¤„ç†è¿›ä½\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) { struct ListNode *head = NULL, *tail = NULL; int carry = 0; while (l1 || l2) { int n1 = l1 ? l1-\u0026gt;val : 0; int n2 = l2 ? l2-\u0026gt;val : 0; int sum = n1 + n2 + carry; if (!head) { head = tail = malloc(sizeof(struct ListNode)); tail-\u0026gt;val = sum % 10; tail-\u0026gt;next = NULL; } else { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = sum % 10; tail = tail-\u0026gt;next; tail-\u0026gt;next = NULL; } carry = sum / 10; if (l1) { l1 = l1-\u0026gt;next; } if (l2) { l2 = l2-\u0026gt;next; } } if (carry \u0026gt; 0) { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = carry; tail-\u0026gt;next-\u0026gt;next = NULL; } return head; } 3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² æ€è·¯ï¼šåŒæŒ‡é’ˆï¼Œå‰åå¿«æ…¢æŒ‡é’ˆï¼Œtableè¡¨æ ‡è®°å­—ç¬¦æ˜¯å¦å‡ºç°è¿‡ï¼Œrightæ ‡è®°ï¼Œleftå»é™¤æ ‡è®°ï¼Œæ±‚right-leftæœ€å¤§å€¼\nint lengthOfLongestSubstring(char * s){ int len = strlen(s); printf(\u0026#34;len = %d\\n\u0026#34;, len); int left = 0; int right = 0; char table[256] = {0}; int maxLen = 0; while (right \u0026lt; len) { printf(\u0026#34;%d \\t\u0026#34;, right); if (table[s[right]] == 0) { table[s[right]] = 1; right++; //} else if (table[s[right]] == 1) { } else { table[s[left]] = 0; left++; } maxLen = fmax(maxLen, right - left); } return maxLen; } 4.å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•° æ€è·¯ï¼šæ¯ä¸ªæ•°ç»„å„è‡ªç´¢å¼•ï¼Œåˆ¤æ–­å¤§å°ç§»åŠ¨ç´¢å¼•ï¼Œæœ€ååˆ¤æ–­æ˜¯å¥‡æ•°è¿˜æ˜¯å¶æ•°\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){ int sum = nums1Size + nums2Size; int *nums = (int *)malloc(sizeof(int) * sum); int i = 0, j = 0, k = 0; int half = sum / 2 + 1; while (k \u0026lt; half) { int n; if (i \u0026lt; nums1Size \u0026amp;\u0026amp; j \u0026lt; nums2Size) { n = (nums1[i] \u0026lt; nums2[j]) ? nums1[i++] : nums2[j++]; } else if (i \u0026lt; nums1Size) { n = nums1[i++]; } else if (j \u0026lt; nums2Size) { n = nums2[j++]; } nums[k++] = n; } if (sum % 2 == 0) { return (nums[k-1] + nums[k-2]) / 2.0; } else { return nums[k-1]; } } 6.Z å­—å½¢å˜æ¢ æ€è·¯ï¼šè®¡ç®—ä½ç½®ï¼Ÿ\nchar * convert(char * s, int numRows){ uint16_t len = strlen(s); if (len \u0026lt; numRows) { numRows = len; } char* out = calloc(len + 1, sizeof(char)); if (numRows \u0026lt; 2) { memcpy(out, s, len + 1); return out; } uint16_t max = numRows - 1; uint16_t rr = 2 * max; uint16_t i = 0; uint16_t o = 0; uint16_t delta = 0; // first row while (i \u0026lt; len) { out[o++] = s[i]; i += rr; } // middle rows for (uint16_t l = 1; l \u0026lt; max; l++) { i = l; delta = 2 * l; while (i \u0026lt; len) { out[o++] = s[i]; delta = rr - delta; i += delta; } } // last row i = max; while (i \u0026lt; len) { out[o++] = s[i]; i += rr; } return out; } 7.æ•´æ•°åè½¬ æ€è·¯ï¼š(å–ä½™æ•°)* 10ï¼Œæ³¨æ„è¶Šç•Œï¼ŒINT_MAX / 10 \u0026amp;\u0026amp; pop \u0026gt; 7\nint reverse(int x){ int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev \u0026gt; INT_MAX / 10 || (rev == INT_MAX / 10 \u0026amp;\u0026amp; pop \u0026gt; 7)) return 0; if (rev \u0026lt; INT_MIN / 10 || (rev == INT_MIN / 10 \u0026amp;\u0026amp; pop \u0026lt; -8)) return 0; rev = rev * 10 + pop; } return rev; } 8.å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi) æ€è·¯ï¼š\nint myAtoi(char * s){ long flag = 1; long num = 0; //int singleRes=0; while(*s == \u0026#39; \u0026#39;) { s++; } if(*s==\u0026#39;-\u0026#39;) { flag=-1; s++; } else if (*s==\u0026#39;+\u0026#39;) { s++; flag=1; } while(*s!=\u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; (*s\u0026lt;=\u0026#39;9\u0026#39; \u0026amp;\u0026amp; *s\u0026gt;=\u0026#39;0\u0026#39;)) { if(num\u0026gt;INT_MAX/10 || (num==INT_MAX/10 \u0026amp;\u0026amp; *s\u0026gt;\u0026#39;7\u0026#39;)){//å› ä¸ºæ˜¯ä»æ­£æ•°è½¬åŒ–ä¸ºè´Ÿæ•°ï¼Œæ‰€ä»¥è¦éƒ½æŒ‰æ­£æ•°æº¢å‡ºæ ‡å‡† if(flag==1) { return INT_MAX; } else { return INT_MIN; } } else { num=num*10+(*s-\u0026#39;0\u0026#39;); s++; } } if(flag==1) { return num; } else { return -num; } } int myAtoi(char * s){ int minusFlag = 0; int length = strlen(s); long int result = 0; char numberBuffer[11]; int counter = 0; while (s[counter] == \u0026#39; \u0026#39;) { counter++; } s = \u0026amp;s[counter]; counter = 0; for (int i = 0; i \u0026lt; length; i++) { if (i == 0) { if (s[0] == \u0026#39;-\u0026#39;) { minusFlag = 1; i++; } else if (s[0] == \u0026#39;+\u0026#39;) { i++; } } if (counter \u0026gt; 10) { if (minusFlag) { return __INT_MAX__ * -1 - 1; } else { return __INT_MAX__; } } if (s[i] \u0026lt; \u0026#39;0\u0026#39; || s[i] \u0026gt; \u0026#39;9\u0026#39;) { break; } if (counter == 0 \u0026amp;\u0026amp; s[i] == \u0026#39;0\u0026#39;) { continue; } numberBuffer[counter] = s[i]; counter++; } int i = 0; while (counter \u0026gt; 0) { if (minusFlag) { result -= (numberBuffer[i] - \u0026#39;0\u0026#39;) * pow(10.0, counter - 1); } else { result += (numberBuffer[i] - \u0026#39;0\u0026#39;) * pow(10.0, counter - 1); } i++; counter--; } if (result \u0026gt; __INT_MAX__) { return __INT_MAX__; } else if (result \u0026lt; __INT_MAX__ * -1 - 1) { return __INT_MAX__ * -1 - 1; } return result; } 9.å›æ–‡æ•° æ€è·¯ï¼šå°†æ¯ä¸€ä½æŒ‰åºè£…å…¥æ•°ç»„ï¼Œéå†æ•°ç»„é¦–å°¾æ˜¯å¦ç›¸ç­‰ ; é€’å½’\nbool isPalindrome(int x) { if (x \u0026lt; 0) { return false; } int table[20] = {0}; int count = 0; while (x) { table[count++] = x % 10; x = x / 10; printf(\u0026#34;x = %d\\n\u0026#34;, x); } for (int i = 0; i \u0026lt; count / 2; i++) { if (table[i] != table[count - i - 1]) { return false; } } return true; } bool isPalindrome(int x){ if (x \u0026lt; 0 || (x % 10 == 0 \u0026amp;\u0026amp; x != 0)) { return false; } int revertedNumber = 0; while (x \u0026gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; } 11.ç››æœ€å¤šæ°´çš„å®¹å™¨ æ€è·¯ï¼šåŒæŒ‡é’ˆï¼Œå¤´å°¾å‘ä¸­é—´\nint maxArea(int* height, int heightSize) { int left = 0; int right = heightSize - 1; int maxNum = 0; while (left \u0026lt; right) { int hMax = fmin(height[left], height[right]); int tmp = hMax * (right - left); maxNum = fmax(maxNum, tmp); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return maxNum; } int maxArea(int* height, int heightSize) { int left = 0; int right = heightSize - 1; int mArea = 0; while (left \u0026lt; right) { int h = fmin(height[left], height[right]); int m = h * (right - left); mArea = fmax(mArea, m); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return mArea; } int maxArea(int* height, int heightSize){ // Start with maximum container width int start = 0; int end = heightSize - 1; int res = 0; while (start \u0026lt; end) { // Calculate current area by taking minimum of two heights int currArea = (end - start) * fmin(height[start], height[end]); if (currArea \u0026gt; res) res = currArea; if (height[start] \u0026lt; height[end]) { start = start + 1; } else { end = end - 1; } } return res; } 12.æ•´æ•°è½¬ç½—é©¬æ•°å­— æ€è·¯ï¼š\nconst int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; const char* symbols[] = {\u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34;}; char* intToRoman(int num) { char* roman = malloc(sizeof(char) * 16); roman[0] = \u0026#39;\\0\u0026#39;; for (int i = 0; i \u0026lt; 13; i++) { while (num \u0026gt;= values[i]) { num -= values[i]; strcpy(roman + strlen(roman), symbols[i]); } if (num == 0) { break; } } return roman; } char *getOne(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;IX\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;VIII\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;VII\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;VI\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;V\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;IV\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;III\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;II\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;I\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getTen(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;XC\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;LXXX\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;LXX\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;LX\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;L\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;XL\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;XXX\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;XX\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;X\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getHundred(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;CM\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;DCCC\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;DCC\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;DC\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;D\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;CD\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;CCC\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;CC\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;C\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getThousand(char c) { switch (c) { case \u0026#39;3\u0026#39;: return \u0026#34;MMM\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;MM\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;M\u0026#34;; default: return NULL; } } char * intToRoman(int num){ int length; char number[5]; char *s = malloc(16 * sizeof(char)); sprintf(number, \u0026#34;%i\u0026#34;, num); length = strlen(number); switch (length) { case 4: sprintf(s, \u0026#34;%s%s%s%s\u0026#34;, getThousand(number[0]), getHundred(number[1]), getTen(number[2]), getOne(number[3])); break; case 3: sprintf(s, \u0026#34;%s%s%s\u0026#34;, getHundred(number[0]), getTen(number[1]), getOne(number[2])); break; case 2: sprintf(s, \u0026#34;%s%s\u0026#34;, getTen(number[0]), getOne(number[1])); break; case 1: s = getOne(number[0]); break; default: break; } return s; } 13.ç½—é©¬æ•°å­—è½¬æ•´æ•° æ€è·¯ï¼š\nint romanToInt(char * s){ int romanToInt = 0; for (int i = 0; i \u0026lt; strlen(s); i++) { switch (s[i]) { case \u0026#39;I\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;V\u0026#39; || s[i + 1] == \u0026#39;X\u0026#39;) { romanToInt -= 1; break; } } romanToInt += 1; break; case \u0026#39;V\u0026#39;: romanToInt += 5; break; case \u0026#39;X\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;L\u0026#39; || s[i + 1] == \u0026#39;C\u0026#39;) { romanToInt -= 10; break; } } romanToInt += 10; break; case \u0026#39;L\u0026#39;: romanToInt += 50; break; case \u0026#39;C\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;D\u0026#39; || s[i + 1] == \u0026#39;M\u0026#39;) { romanToInt -= 100; break; } } romanToInt += 100; break; case \u0026#39;D\u0026#39;: romanToInt += 500; break; case \u0026#39;M\u0026#39;: romanToInt += 1000; break; default: break; } } return romanToInt; } 20.æœ‰æ•ˆçš„æ‹¬å· æ€è·¯ï¼šé…å¯¹åˆ¤æ–­\nbool isValid(char * s) { int i, k = 0, len = strlen(s); char *store = calloc(len, sizeof(char)); for (i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { switch (s[i]) { case \u0026#39;(\u0026#39;: case \u0026#39;{\u0026#39;: case \u0026#39;[\u0026#39;: store[k++] = s[i]; break; case \u0026#39;)\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;(\u0026#39;) goto out; break; case \u0026#39;}\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;{\u0026#39;) goto out; break; case \u0026#39;]\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;[\u0026#39;) goto out; break; } } out: free(store); return s[i] == \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; k == 0; } 21.åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ æ€è·¯ï¼šå…ˆæ·»åŠ å¤´ï¼Œç„¶ååˆ¤æ–­ l1 != NULL \u0026amp;\u0026amp; l2 != NULL æ·»åŠ è°\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { struct ListNode* head = NULL; struct ListNode* tmp = NULL; if (l1 == NULL) { return l2; } if (l2 == NULL) { return l1; } if (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { head = tmp = l1; l1 = l1-\u0026gt;next; } else { head = tmp = l2; l2 = l2-\u0026gt;next; } while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { tmp-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { tmp-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } tmp = tmp-\u0026gt;next; } if (l1) { tmp-\u0026gt;next = l1; } if (l2) { tmp-\u0026gt;next = l2; } return head; } return NULL; } struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { struct ListNode *list = NULL; struct ListNode *tmp = NULL; if (!l1) return l2; if (!l2) return l1; if (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { list = tmp = l1; l1 = l1-\u0026gt;next; } else { list = tmp = l2; l2 = l2-\u0026gt;next; } while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { tmp-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { tmp-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } tmp = tmp-\u0026gt;next; } if (l1) tmp-\u0026gt;next = l1; if (l2) tmp-\u0026gt;next = l2; return list; } return NULL; } /* if (!list1) return list2; if (!list2) return list1; if (list1-\u0026gt;val \u0026lt; list2-\u0026gt;val) { list1-\u0026gt;next = mergeTwoLists(list1-\u0026gt;next, list2); return list1; } else { list2-\u0026gt;next = mergeTwoLists(list1, list2-\u0026gt;next); return list2; } */ 24.ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ æ€è·¯ï¼šé€’å½’ï¼›å€ŸåŠ©èŠ‚ç‚¹\nstruct ListNode* swapPairs(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* first = head-\u0026gt;next; head-\u0026gt;next = swapPairs(head-\u0026gt;next-\u0026gt;next); first-\u0026gt;next = head; head = head-\u0026gt;next; return first; } struct ListNode* swapPairs(struct ListNode* head) { if (!head || !head-\u0026gt;next) return head; struct ListNode *tmp = head-\u0026gt;next; head-\u0026gt;next = swapPairs(head-\u0026gt;next-\u0026gt;next); tmp-\u0026gt;next = head; return tmp; } 26.åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ æ€è·¯ï¼š++\nint removeDuplicates(int* nums, int numsSize) { if(numsSize == 0) { return 0; } int fast = 1, low = 0; while (fast \u0026lt; numsSize) { if (nums[fast] != nums[low]) { nums[low + 1] = nums[fast]; low++; } fast++; } return low + 1; } int removeDuplicates(int* nums, int numsSize) { int count = 0, i; for (i = 1; i \u0026lt; numsSize; i++) { if (nums[i] == nums[i - 1]) count++; else nums[i - count] = nums[i]; } return numsSize - count; } 27.ç§»é™¤å…ƒç´  æ€è·¯ï¼šnums[start++] = nums[i];\nint removeElement(int* nums, int numsSize, int val){ int i, start = 0; for (i = 0; i \u0026lt; numsSize; i++) { if (nums[i] != val) { nums[start++] = nums[i]; } } return start; } 28.å®ç° strStr() æ€è·¯ï¼š\nint strStr(char * haystack, char * needle){ int i = 0; int j = 0; int k = 0; int hlen = 0; int nlen = 0; if (needle == NULL || *needle == 0) return 0; if (haystack == NULL || *haystack == 0) return -1; hlen = strlen(haystack); nlen = strlen(needle); if (hlen \u0026lt; nlen) return -1; for (i = 0; i \u0026lt;= hlen - nlen; i++) { j = 0; if (haystack[i] != needle[j++]) continue; k = i + 1; for (; j \u0026lt; nlen; j++) { if (haystack[k] != needle[j]) { break; } else { k++; } } if (j == nlen) return i; } return -1; } 29.ä¸¤æ•°ç›¸é™¤ æ€è·¯ï¼š\nint divide(int dividend, int divisor) { int cnt = 0; int sign = 1; if ((dividend ^ divisor) \u0026lt; 0) { // ä¸¤æ•°ä»»æ„ä¸€ä¸ªä¸ºè´Ÿæ•° sign = -1; } if (divisor == INT_MIN) { // é™¤æ•°è¾¹ç•Œå€¼ç‰¹æ®Šå¤„ç† if (dividend == INT_MIN) { return 1; } else { return 0; } } if (dividend == INT_MIN) { // è¢«é™¤æ•°è¾¹ç•Œå€¼ç‰¹æ®Šå¤„ç† if (divisor == -1) { return INT_MAX; } else if (divisor == 1) { return INT_MIN; } dividend += abs(divisor); // å…ˆæ‰§è¡Œä¸€æ¬¡åŠ æ“ä½œï¼Œé¿å…absè½¬æ¢æº¢å‡º cnt++; } int a = abs(dividend); int b = abs(divisor); while (a \u0026gt;= b) { int c = 1; int s = b; // éœ€æŒ‡æ•°çº§å¿«é€Ÿé€¼è¿‘ï¼Œä»¥é¿å…æ‰§è¡Œè¶…æ—¶ while (s \u0026lt; (a \u0026gt;\u0026gt; 1)) { // é€¼è¿‘è‡³ä¸€åŠï¼ŒåŒæ—¶é¿å…æº¢å‡º s += s; c += c; } cnt += c; a -= s; } return (sign == -1) ? -cnt : cnt; } int divide(int dividend, int divisor){ int sign = 1; long int output = 0; if (dividend \u0026lt; 0) { sign *= -1; } else { dividend *= -1; } if (divisor \u0026lt; 0) { sign *= -1; } else { divisor *= -1; } while (dividend \u0026lt;= divisor) { long int tmp = 0; long int div = divisor; while (dividend \u0026lt;= div) { tmp += (tmp + 1); dividend -= div; div += div; } if (output \u0026gt;= INT_MAX) { if (sign == -1) { return INT_MIN; } else { return INT_MAX; } } output += tmp; } return output * sign; } 35.æœç´¢æ’å…¥ä½ç½® æ€è·¯ï¼š\nint searchInsert(int* nums, int numsSize, int target) { int left = 0; int right = numsSize - 1; int mid; while (left \u0026lt;= right) { // mid = (right + left) / 2; mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return left; } int searchInsert(int* nums, int numsSize, int target) { int idx = numsSize - 1; if (numsSize \u0026gt; 0) { if (target \u0026gt; nums[idx]) { return numsSize; } return searchInsert(nums, numsSize - 1, target); } return 0; } 38.å¤–è§‚æ•°åˆ— æ€è·¯ï¼š\nchar * countAndSay(int n) { char *p = (char *)malloc(5000); char *p1 = (char *)malloc(5000); p[0] = \u0026#39;1\u0026#39;; p[1] = \u0026#39;\\0\u0026#39;; for(int i = 1; i \u0026lt; n; ++i) { int x = 0; for(int j = 0; p[j]; ++j) { int y = 1; //è®¡æ•°å™¨ while (p[j+1] \u0026amp;\u0026amp; p[j] == p[j+1]) { ++y; ++j; } p1[x++] = y+48; p1[x++] = p[j]; } strcpy(p, p1); p[x] = \u0026#39;\\0\u0026#39;; } return p; } char * countAndSay(int n) { // Calculating the length of array double result = 1.0; for (int i = 0; i \u0026lt; n - 1; i++) { result *= 1.4; } int k, j, count, convert = (int)result; // Creating array with the length calculated above char *arr = malloc(convert + 4); arr[0] = \u0026#39;1\u0026#39;; arr[1] = \u0026#39;\\0\u0026#39;; for (int i = 2, length; i \u0026lt;= n; i++) { length = strlen(arr); char newArr[length * 2]; strcpy(newArr, arr); k = 0; j = 0; count = 1; while (newArr[j] != \u0026#39;\\0\u0026#39;) { if (newArr[j] == newArr[j + 1]) { count++; j++; } else { arr[k] = (48 + count); arr[k + 1] = newArr[j]; arr[k + 2] = \u0026#39;\\0\u0026#39;; j++; k += 2; count = 1; } } } return arr; } 53.æœ€å¤§å­æ•°ç»„å’Œ æ€è·¯ï¼šç´¯åŠ ï¼ŒåŠ¨æ€è§„åˆ’\nint maxcmp(int a, int b) { return a \u0026gt;= b ? a : b; } int maxSubArray(int* nums, int numsSize) { int maxSoFar = nums[0]; int maxEndingHere = nums[0]; for (int i = 1; i \u0026lt; numsSize; i++) { maxEndingHere = maxcmp(maxEndingHere + nums[i], nums[i]); maxSoFar = maxcmp(maxSoFar, maxEndingHere); } return maxSoFar; } 66.åŠ ä¸€ æ€è·¯ï¼šåˆ¤æ–­æ˜¯å¦å‘ç”Ÿè¿›ä½ï¼Œæœ€ååˆ¤æ–­æœ€é«˜ä½æ˜¯å¦è¿›ä½\n// The returned array must be malloced, assume caller calls free(). int *plusOne(int *digits, int digitsSize, int *returnSize) { for (int i = digitsSize - 1; i \u0026gt;= 0; i--) { if (digits[i] \u0026lt; 9) { digits[i]++; *returnSize = digitsSize; return digits; } else { digits[i] = 0; } } int* newdigit = (int *)malloc(sizeof(int) * (digitsSize + 1)); newdigit[0] = 1; for (int i = 1; i \u0026lt; (digitsSize + 1); i++) { newdigit[i] = digits[i-1]; } *returnSize = digitsSize + 1; return newdigit; } int* plusOne(int* digits, int digitsSize, int* returnSize) { *returnSize = digitsSize; digits[digitsSize - 1] += 1; int carry = digits[digitsSize - 1] / 10; for (int i = digitsSize - 1; i \u0026gt;= 0; i--) { digits[i] = (carry + digits[i]) % 10; int t = carry; carry = (carry + digits[i]) / 10; printf(\u0026#34;carry = %d\\n\u0026#34;, carry); } if (carry == 1) { *returnSize = digitsSize + 1; int *res = malloc(sizeof(int) * (*returnSize)); res[0] = 1; for (int i = 0; i \u0026lt; digitsSize; i++) { res[i+1] = digits[i]; } return res; } return digits; } 82.åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II æ€è·¯ï¼šé€’å½’ï¼Œåˆ¤æ–­æ˜¯å¦å’Œä¸‹ä¸€ä¸ªé“¾è¡¨å€¼ç›¸ç­‰\nstruct ListNode* deleteDuplicates(struct ListNode* head) { /* if (head == NULL) { return NULL; } if (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { head = head-\u0026gt;next; } return deleteDuplicates(head-\u0026gt;next); } else { head-\u0026gt;next = deleteDuplicates(head-\u0026gt;next); } return head; */ if (head == NULL) return NULL; if (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { /* Remove all duplicate numbers */ while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { head = head-\u0026gt;next; } return deleteDuplicates(head-\u0026gt;next); } else { head-\u0026gt;next = deleteDuplicates(head-\u0026gt;next); } return head; } 83.åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  æ€è·¯ï¼šåˆ¤æ–­ç›¸ç­‰ï¼Œnext = next-\u0026gt;next\n/* struct ListNode* deleteDuplicates(struct ListNode* head){ if (head == NULL) { return NULL; } int table[201] = {0}; struct ListNode* cur = head; table[cur-\u0026gt;val + 100] = 1; while (cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;next) { if (table[cur-\u0026gt;next-\u0026gt;val + 100] == 1) { if (cur-\u0026gt;next-\u0026gt;next != NULL) { cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; continue; } else { cur-\u0026gt;next = NULL; break; } } else { table[cur-\u0026gt;next-\u0026gt;val + 100] = 1; } cur = cur-\u0026gt;next; } return head; } */ struct ListNode* deleteDuplicates(struct ListNode* head) { struct ListNode* cur = head; while (cur \u0026amp;\u0026amp; cur-\u0026gt;next) { if (cur-\u0026gt;val == cur-\u0026gt;next-\u0026gt;val) { cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; } else { cur = cur-\u0026gt;next; } } return head; } /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* deleteDuplicates(struct ListNode* head) { if (head == NULL) { return NULL; } else { struct ListNode* s = head; struct ListNode* t = head-\u0026gt;next; while (t != NULL) { if (s-\u0026gt;val == t-\u0026gt;val) { struct ListNode* y; y=s-\u0026gt;next; s-\u0026gt;next=t-\u0026gt;next; t=y-\u0026gt;next; free(y); } else { s=s-\u0026gt;next; t=t-\u0026gt;next; } } } return head; } 84.æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢ æ€è·¯ï¼šå•è°ƒæ ˆï¼Ÿ\nint largestRectangleArea(int* heights, int heightsSize){ /* int *data = (int*)malloc(sizeof(int) * (heightsSize + 2)); int *stack = (int*)malloc(sizeof(int) * (heightsSize + 2)); //ç»™heightså‰å+0ï¼Œæˆæ–°æ•°ç»„data data[0] = 0; for (int i = 1; i \u0026lt;= heightsSize; i++) { data[i] = heights[i - 1]; } data[heightsSize + 1] = 0; int j = 0, area = 0; stack[j] = 0; for (int i = 1; i \u0026lt;= heightsSize + 1; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; data[stack[j]] \u0026gt;= data[i]) { int sidx = stack[j - 1]; int h = data[stack[j]]; //area = fmax(area, data[stack[top]] * (i - stack[top - 1] - 1)); area = fmax(area, h * (i - sidx - 1)); j--; } stack[++j] = i; } return area; */ int* stack = (int*)malloc(sizeof(int) * (heightsSize + 2)); int* nheights = (int*)malloc(sizeof(int) * (heightsSize + 2)); for (int i = 0; i \u0026lt; heightsSize; i++) { nheights[i+1] = heights[i]; } nheights[0] = 0; nheights[heightsSize + 1] = 0; int maxArea = 0; int top = 0; stack[top] = 0; for (int i = 1; i \u0026lt;= heightsSize + 1; i++) { while (top \u0026gt; 0 \u0026amp;\u0026amp; nheights[stack[top]] \u0026gt;= nheights[i]) { int h = nheights[stack[top]]; int s = stack[top - 1]; int area = nheights[stack[top]] * (i - s -1); maxArea = fmax(maxArea, area); top--; } top++; stack[top] = i; } return maxArea; } void showIntArr(const char *brief, int *arr, uint32_t nums) { printf(\u0026#34;%s:\u0026#34;, brief); for (uint32_t i = 0; i \u0026lt; nums; i++) { printf(\u0026#34;%d \u0026#34;,arr[i]); } printf(\u0026#34;\\n\u0026#34;); return; } int largestRectangleArea(int* heights, int heightsSize){ int *stack = (int *)malloc(sizeof(int) * (heightsSize + 1)); uint32_t stackIdx = 0; int maxAns = 0; int tmpAns = 0; int high = 0; int wide = 0; stack[stackIdx++] = -1; for (uint32_t i = 0; i \u0026lt; heightsSize; i++) { //showIntArr(\u0026#34;stack\u0026#34;, stack, stackIdx); if (stackIdx == 1) { /* å•è°ƒæ ˆä¸ºç©º */ stack[stackIdx++] = i; continue; } // printf(\u0026#34;stackIdx - 1 [%d]\\n\u0026#34;, stackIdx - 1); if (heights[i] \u0026gt;= heights[stack[stackIdx - 1]]) { stack[stackIdx++] = i; continue; } while ((stackIdx \u0026gt; 1) \u0026amp;\u0026amp; heights[i] \u0026lt; heights[stack[stackIdx - 1]]) { /* éå†åˆ°çš„å…ƒç´ å°äºæ ˆé¡¶å…ƒç´  */ high = heights[stack[stackIdx - 1]]; stackIdx--; wide = i - stack[stackIdx - 1] - 1; tmpAns = high * wide; //printf(\u0026#34;i[%u] high[%d] wide[%d]\\n\u0026#34;, i, high, wide); if (tmpAns \u0026gt; maxAns) { maxAns = tmpAns; } } stack[stackIdx++] = i; } while (stackIdx \u0026gt; 1) { high = heights[stack[stackIdx - 1]]; stackIdx--; wide = heightsSize - stack[stackIdx - 1] - 1; tmpAns = high * wide; //printf(\u0026#34;ele[%d] high[%d] wide[%d]\\n\u0026#34;, heightsSize, high, wide); if (tmpAns \u0026gt; maxAns) { maxAns = tmpAns; } } return maxAns; } 94.äºŒå‰æ ‘çš„ä¸­åºéå† æ€è·¯ï¼šé€’å½’ï¼Œä¸­åºï¼Œæ³¨æ„å°è£…é€’å½’å‡½æ•°\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ void processTraversal(struct TreeNode* root, int* res, int* size) { if (!root) { return; } processTraversal(root-\u0026gt;left, res, size); res[*size] = root-\u0026gt;val; *size += 1; processTraversal(root-\u0026gt;right, res, size); } int* inorderTraversal(struct TreeNode* root, int* returnSize){ int* res = malloc(sizeof(int) * 256); *returnSize = 0; processTraversal(root, res, returnSize); return res; } 101.å¯¹ç§°äºŒå‰æ ‘ æ€è·¯ï¼šé€’å½’åˆ¤æ–­ï¼Œæ³¨æ„é€’å½’å‡ºå£åˆ¤æ–­æ¡ä»¶\nbool checkSymmetric(struct TreeNode *left, struct TreeNode *right) { if (!left || !right) return left == right; if (left-\u0026gt;val != right-\u0026gt;val) return 0; return checkSymmetric(left-\u0026gt;left, right-\u0026gt;right) \u0026amp;\u0026amp; checkSymmetric(left-\u0026gt;right, right-\u0026gt;left); } bool isSymmetric(struct TreeNode *root) { return root == NULL || checkSymmetric(root-\u0026gt;left, root-\u0026gt;right); } 104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ æ€è·¯ï¼šæ±‚æ ‘æ·±åº¦é€’å½’ return 1 + maxval(maxDepth(root-\u0026gt;left), maxDepth\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int maxval(int a, int b) { return a \u0026gt; b ? a : b; } int maxDepth(struct TreeNode *root) { if (root == NULL) { return 0; } return 1 + maxval(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)); } int max(int a, int b) { return a \u0026gt;= b ? a : b; } int height(struct TreeNode* root) { if (root == NULL) { return 1; } return 1 + max(height(root-\u0026gt;left), height(root-\u0026gt;right)); } int maxDepth(struct TreeNode* root) { if (root == NULL) { return 0; } int left = height(root-\u0026gt;left); int right = height(root-\u0026gt;right); return fmax(left, right); } 108.å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘ æ€è·¯ï¼šé€’å½’å¤„ç†ä»ä¸­é—´åˆ†å·¦å³ä¸¤éƒ¨åˆ†ï¼Œå…ˆæ·»åŠ å½“å‰èŠ‚ç‚¹åœ¨é€’å½’ã€‚\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* convertBST(int* nums, int left, int right) { if (left \u0026gt; right) { return NULL; } else { int mid = (right + left) / 2; struct TreeNode* new_val = malloc(sizeof(struct TreeNode)); new_val-\u0026gt;val = nums[mid]; new_val-\u0026gt;left = convertBST(nums, left, mid - 1); new_val-\u0026gt;right = convertBST(nums, mid + 1, right); return new_val; } } struct TreeNode* sortedArrayToBST(int* nums, int numsSize){ if (numsSize == 0) { return NULL; } return convertBST(nums, 0, numsSize - 1); } 109.æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘ æ€è·¯ï¼šå…ˆæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹ï¼Œå°†ä¸­é—´èŠ‚ç‚¹æ·»åŠ åˆ°æ ‘ä¸Šï¼Œé€’å½’å¤„ç†ä¸­é—´èŠ‚ç‚¹å‰éƒ¨å’Œåéƒ¨ä¸¤éƒ¨åˆ†ï¼Œé€’å½’å‡ºå£ä¸ºæ‰¾ä¸ç€æ–°èŠ‚ç‚¹\n/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* buildBST(struct ListNode* head, struct ListNode* tail) { if (head == tail) { return NULL; } struct ListNode* slow = head; struct ListNode* fast = head; while (fast != tail \u0026amp;\u0026amp; fast-\u0026gt;next != tail) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } //struct TreeNode* node = (struct TreeNode)malloc(sizeof(struct TreeNode)); struct TreeNode *node = malloc(sizeof(struct TreeNode)); node-\u0026gt;val = slow-\u0026gt;val; node-\u0026gt;left = buildBST(head, slow); node-\u0026gt;right = buildBST(slow-\u0026gt;next, tail); return node; } struct TreeNode* sortedListToBST(struct ListNode* head){ if (!head) { return NULL; } return buildBST(head, NULL); } 110.å¹³è¡¡äºŒå‰æ ‘ æ€è·¯ï¼šåˆ†åˆ«æ±‚å·¦å³å­æ ‘çš„æ·±åº¦heightï¼Œæ¯”è¾ƒå·¦å³æ·±åº¦å·®å€¼ã€‚é€’å½’åˆ¤æ–­å·¦å³å­æ ‘æ˜¯å¦ä¸ºå¹³è¡¡äºŒå‰æ ‘\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int max(int a, int b) { return a \u0026gt;= b ? a : b; } int height(struct TreeNode* root) { if (root == NULL) { return 0; } else { return 1 + max(height(root-\u0026gt;left), height(root-\u0026gt;right)); } } bool isBalanced(struct TreeNode* root){ if (root == NULL) { return 1; } int left = height(root-\u0026gt;left); int right = height(root-\u0026gt;right); return abs(left - right) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root-\u0026gt;left) \u0026amp;\u0026amp; isBalanced(root-\u0026gt;right); } 112. è·¯å¾„æ€»å’Œ æ€è·¯ï¼šé€’å½’ï¼šå·¦å³å­æ ‘ é€’å½’å‡ºå£ï¼› æ³¨æ„ä¹¦åˆ¤ç©º\nbool hasPathSum(struct TreeNode* root, int targetSum){ if (root == NULL) { return false; } if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL \u0026amp;\u0026amp; root-\u0026gt;val == targetSum) { return true; } return hasPathSum(root-\u0026gt;left, targetSum - root-\u0026gt;val) || hasPathSum(root-\u0026gt;right, targetSum - root-\u0026gt;val); } 121.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº æ€è·¯ï¼šåŠ¨æ€è§„åˆ’ï¼Œè‚¡ç¥¨æ˜¯è¿ç»­æ”¶ç›Šçš„ maxcmp(0, maxCur + prices[i] - prices[i - 1])ï¼Œæ”¶ç›Šç´¯è®¡\nint maxcmp(int a, int b) { return (a \u0026gt;= b) ? a : b; } int maxProfit(int* prices, int pricesSize){ int maxCur = 0, maxSoFar = 0; for (int i = 1; i \u0026lt; pricesSize; i++) { maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]); maxSoFar = maxcmp(maxSoFar, maxCur); printf(\u0026#34;i = %d\\t maxCur = %d \\t maxSoFar = %d\\n\u0026#34;, i, maxCur, maxSoFar); } return maxSoFar; } 125.éªŒè¯å›æ–‡ä¸² æ€è·¯ï¼šåˆ¤æ–­æ˜¯å¦æ˜¯å­—æ¯å’Œæ•°å­—ï¼Œåº“å‡½æ•° isalnum; æ³¨æ„åº“å‡½æ•° isalpha ä¸ºåˆ¤æ–­æ˜¯å¦ä¸ºå­—æ¯ã€‚å¤´å°¾åŒæŒ‡é’ˆï¼Œé€¼è¿‘ä¸­é—´ï¼Œæ³¨æ„éæ•°å­—å­—æ¯å¿½ç•¥\nbool isPalindrome(char * s){ int len = strlen(s); int left = 0; int right = len - 1; while (left \u0026lt;= right) { //while (left \u0026lt; right \u0026amp;\u0026amp; !isalpha(s[left])) { while (left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[left])) { left++; } //while (left \u0026lt; right \u0026amp;\u0026amp; !isalpha(s[right])) { while (left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[right])) { right--; } printf(\u0026#34;left = %d\\t right = %d\\n\u0026#34;, left, right); if (tolower(s[left]) != tolower(s[right])) { return false; } left++; right--; } return true; } 136.åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— æ€è·¯ï¼šn ^ n = 0 ä¸€ä¸ªæ•°ä¸è‡ªå·±å¼‚æˆ–ä¸º 0\nint singleNumber(int* nums, int numsSize){ int res = 0; for (int i = 0; i \u0026lt; numsSize; i++) { res = res ^ nums[i]; } return res; } 141.ç¯å½¢é“¾è¡¨ æ€è·¯ï¼šå¿«æ…¢åŒæŒ‡é’ˆï¼Œfastä¸€æ¬¡èµ°ä¸¤æ­¥ï¼Œslowä¸€æ¬¡èµ°ä¸€æ­¥ï¼Œåˆ¤æ–­æ˜¯å¦èƒ½ç›¸é‡\nbool hasCycle(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; while (slow \u0026amp;\u0026amp; fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) { return true; } } return false; } 142.ç¯å½¢é“¾è¡¨ II æ€è·¯ï¼šå¿«æ…¢åŒæŒ‡é’ˆï¼Œåˆ¤æ–­å‡ºç¯å‘åï¼Œä»é“¾è¡¨å…¥å£å¼€å§‹ï¼Œå’ŒslowæŒ‡é’ˆç›¸åŒé€Ÿåº¦éå†ï¼Œç›´åˆ°ç›¸é‡\nstruct ListNode *detectCycle(struct ListNode *head) { struct ListNode* slow = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* fast = (struct ListNode*)malloc(sizeof(struct ListNode)); slow = head; fast = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) { struct ListNode* entry = head; while (slow != entry) { slow = slow-\u0026gt;next; entry = entry-\u0026gt;next; } return entry; } } return NULL; } 153.å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ æ€è·¯ï¼šäºŒåˆ†æŸ¥æ‰¾\nint findMin(int* nums, int numsSize){ int low = 0; int high = numsSize - 1; while (low \u0026lt; high) { int mid = low + (high - low) / 2; if (nums[mid] \u0026lt; nums[high]) { high = mid; } else { low = mid + 1; } } return nums[low]; } int findMin(int* nums, int numsSize){ int i; for (i = 0; i \u0026lt; numsSize - 1; i++) { if (nums[i] \u0026gt; nums[(i+1)]) { return nums[i+1]; } } return nums[0]; } 160.ç›¸äº¤é“¾è¡¨ æ€è·¯ï¼š ä¸€ã€ äºŒã€å…ˆç»Ÿè®¡ä¸¤ä¸ªé“¾è¡¨ç»“ç‚¹ä¸ªæ•°ï¼Œç„¶åé•¿é“¾è¡¨å…ˆèµ°ä¸ªæ•°å·®ä½\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { struct ListNode *cur1 = headA; struct ListNode *cur2 = headB; if (cur1 == NULL || cur2 == NULL) return NULL; while (cur1 \u0026amp;\u0026amp; cur2 \u0026amp;\u0026amp; cur1 != cur2) { cur1 = cur1-\u0026gt;next; cur2 = cur2-\u0026gt;next; if (cur1 == cur2) { return cur1; } if (!cur1) { cur1 = headB; } if (!cur2) { cur2 = headA; } } return cur1; } 169.å¤šæ•°å…ƒç´  æ€è·¯ï¼šé€‰å®šä¸€ä¸ªä¸»å…ƒç´ ï¼Œè®¡æ•°å™¨\nint majorityElement(int* nums, int numsSize){ int count = 1; int majorNum = nums[0]; for (int i = 1; i \u0026lt; numsSize; i++) { if (count == 0) { majorNum = nums[i]; count++; } else if (majorNum == nums[i]) { count++; } else { count--; } } return majorNum; } 173.äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨ æ€è·¯ï¼š\ntypedef struct { int* res; int size; int idx; } BSTIterator; int getTreeSize(struct TreeNode* root) { if (root == NULL) { return 0; } return 1 + getTreeSize(root-\u0026gt;left) + getTreeSize(root-\u0026gt;right); } void inorder(int* ret, int* retSize, struct TreeNode* root) { if (root == NULL) { return; } inorder(ret, retSize, root-\u0026gt;left); ret[(*retSize)++] = root-\u0026gt;val; inorder(ret, retSize, root-\u0026gt;right); } int* inorderTraversal(int* retSize, struct TreeNode* root) { *retSize = 0; int* ret = malloc(sizeof(int) * getTreeSize(root)); inorder(ret, retSize, root); return ret; } BSTIterator* bSTIteratorCreate(struct TreeNode* root) { BSTIterator* ret = malloc(sizeof(BSTIterator)); ret-\u0026gt;res = inorderTraversal(\u0026amp;(ret-\u0026gt;size), root); ret-\u0026gt;idx = 0; return ret; } int bSTIteratorNext(BSTIterator* obj) { return obj-\u0026gt;res[(obj-\u0026gt;idx)++]; } bool bSTIteratorHasNext(BSTIterator* obj) { return (obj-\u0026gt;idx \u0026lt; obj-\u0026gt;size); } void bSTIteratorFree(BSTIterator* obj) { free(obj-\u0026gt;res); free(obj); } 189.è½®è½¬æ•°ç»„ æ€è·¯ï¼š ä¸€ã€æ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªæ•° äºŒã€å…ˆæ•´ä½“ç¿»è½¬ï¼Œåœ¨ç¿»è½¬å‰kä¸ªï¼Œæœ€åç¿»è½¬ numsSize - kä¸ª\nvoid moveOne(int* nums, int numsSize) { int tmp = nums[numsSize - 1]; for (int i = numsSize - 1; i \u0026gt; 0; i--) { nums[i] = nums[i-1]; } nums[0] = tmp; } void rotate(int* nums, int numsSize, int k) { for (int i = 0; i \u0026lt; k; i++) { moveOne(nums, numsSize); } } /* */ void swap(int* a, int* b) { int t = *a; *a = *b; *b = t; } void reverse(int* nums, int start, int end) { while (start \u0026lt; end) { swap(\u0026amp;nums[start], \u0026amp;nums[end]); start += 1; end -= 1; } } void rotate(int* nums, int numsSize, int k) { k %= numsSize; for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, 0, numsSize - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, 0, k - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, k, numsSize - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); } /* void rotate(int* nums, int numsSize, int k){ for (int i = 0; i \u0026lt; k; i++) { int lastElement = nums[numsSize - 1]; for (int j = numsSize - 1; j \u0026gt; 0; j--) { nums[j] = nums[j - 1]; } nums[0] = lastElement; } }*/ /* void rotate(int* nums, int numsSize, int k){ if (k == numsSize / 2 \u0026amp;\u0026amp; numsSize % 2 != 1) { for (int i = 0; i \u0026lt; k; i++) { int tmp = nums[i]; nums[i] = nums[k+i]; nums[k+i] = tmp; } return; } int i = 0; int tmp = nums[0]; int p = 0; int count = 0; do { p = (i + k) % numsSize; printf(\u0026#34;p = %d\\n\u0026#34;,p); int t = nums[p]; nums[p] = tmp; tmp = t; i = p; } while (i != 0); } */ 190.é¢ å€’äºŒè¿›åˆ¶ä½ æ€è·¯ï¼š32ä½ï¼Œ\nuint32_t reverseBits(uint32_t n) { uint32_t m = 0; int cnt = 32; while (cnt) { m \u0026lt;\u0026lt;= 1; m += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;= 1; cnt--; } return m; } 191.ä½1çš„ä¸ªæ•° æ€è·¯ï¼šn \u0026amp; 0x1\nint hammingWeight(uint32_t n) { int cnt = 0; while (n) { if (n \u0026amp; 0x1) { cnt++; } n \u0026gt;\u0026gt;= 1; } return cnt; } 201.æ•°å­—èŒƒå›´æŒ‰ä½ä¸ æ€è·¯ï¼šn \u0026amp; (n - 1) å»é™¤næœ€é«˜ä½çš„1\nint rangeBitwiseAnd(int left, int right){ while (left \u0026lt; right) { right \u0026amp;= right - 1; } return right; } 203.ç§»é™¤é“¾è¡¨å…ƒç´  æ€è·¯ï¼šé€’å½’\nstruct ListNode *removeElements(struct ListNode *head, int val) { if (head == NULL) { return NULL; } if (head-\u0026gt;val == val) { return removeElements(head-\u0026gt;next, val); } else { head-\u0026gt;next = removeElements(head-\u0026gt;next, val); } return head; } 206.åè½¬é“¾è¡¨ æ€è·¯ï¼š\nstruct ListNode* reverseList(struct ListNode* head){ struct ListNode* res = NULL; while (head) { struct ListNode* pre_node = head; head = head-\u0026gt;next; pre_node-\u0026gt;next = res; res = pre_node; } return res; } 209.é•¿åº¦æœ€å°çš„å­æ•°ç»„ æ€è·¯ï¼šåŒæŒ‡é’ˆï¼šç´¯åŠ sumï¼Œåˆ¤æ–­sumï¼Œå¤§äºtargetï¼Œè®¡ç®—é•¿åº¦ï¼Œå‡sumï¼Œç§»åŠ¨left\nint minSubArrayLen(int target, int* nums, int numsSize){ int i = 0; int sum = 0; int len = INT_MAX; for (int j = 0; j \u0026lt; numsSize; j++) { sum += nums[j]; if (sum \u0026lt; target) { continue; } else { while (sum \u0026gt;= target) { len = fmin(len,j-i+1); sum -= nums[i]; i++; } } } if (len==INT_MAX) { len=0; } return len; } int minSubArrayLen(int target, int* nums, int numsSize){ int left = 0; int right = 0; int sum = 0; int len = INT_MAX; while (right \u0026lt; numsSize) { sum += nums[right]; right++; if (sum \u0026lt; target) { continue; } else { while (sum \u0026gt;= target) { len = fmin(len,right-left); sum -= nums[left]; left++; } } } if (len == INT_MAX) { len = 0; } return len; } 215.æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´  æ€è·¯ï¼šæ’åºï¼Œç¬¬kä¸ªæœ€å¤§\nint Cmp(const void* a, const void* b) { return *(int *)b - *(int *)a; } int findKthLargest(int* nums, int numsSize, int k){ qsort(nums, numsSize, sizeof(int), Cmp); return nums[k-1]; } 217.å­˜åœ¨é‡å¤å…ƒç´  æ€è·¯ï¼š ä¸€ã€æ’åºï¼Œæ¯”è¾ƒå‰ä¸€ä¸ªæ•°å’Œå½“å‰æ•°æ˜¯å¦ç›¸ç­‰ äºŒã€uthash\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } bool containsDuplicate(int* nums, int numsSize){ if (numsSize \u0026lt;= 1) { return true; } qsort(nums, numsSize, sizeof(int), Cmp); for (int i = 1; i \u0026lt; numsSize; i++) { if (nums[i-1] == nums[i]) { return true; } } return false; } struct my_struct { int id; UT_hash_handle hh; }; struct my_struct *users = NULL; bool containsDuplicate(int* nums, int numsSize){ struct my_struct *s; HASH_FIND_INT(users, nums[i], s); if (s == NULL) { s = (struct my_struct*)malloc(sizeof(struct my_struct)); s-\u0026gt;id = nums[i]; HASH_ADD_INT(users, id, s); } else { return true; } return false; } 226.ç¿»è½¬äºŒå‰æ ‘ æ€è·¯ï¼šåˆ¤ç©ºï¼Œäº¤æ¢å·¦å³å­æ ‘ï¼Œé€’å½’è°ƒç”¨\nstruct TreeNode* invertTree(struct TreeNode* root){ if (root == NULL) { return NULL; } struct TreeNode* tmp = root-\u0026gt;left; root-\u0026gt;left = root-\u0026gt;right; root-\u0026gt;right = tmp; invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); return root; } struct TreeNode* invertTree(struct TreeNode* root){ if (root == NULL) { return NULL; } struct TreeNode *left = (struct TreeNode *)malloc(sizeof(struct TreeNode)); struct TreeNode *right = (struct TreeNode *)malloc(sizeof(struct TreeNode)); left = invertTree(root-\u0026gt;left); right = invertTree(root-\u0026gt;right); root-\u0026gt;left = right; root-\u0026gt;right = left; return root; } 231.2çš„å¹‚ æ€è·¯ï¼šä¸€ï¼šç´¯è®¡é™¤2ï¼Œåˆ¤æ–­æœ€åæ˜¯å¦ä¸º1ï¼Œå³æ•´é™¤ äºŒã€é€’å½’ï¼Œåˆ¤æ–­å¯¹2å–ä½™\nbool isPowerOfTwo(int n) { if (!n) { return false; } while (n % 2 == 0) { n /= 2; } return n == 1; } bool isPowerOfTwo(int n){ if (n == 0) { return false; } if (n == 1) { return true; } bool res = false; if (n % 2 != 0) { return false; }else { res = isPowerOfTwo(n/2); } return res; } bool isPowerOfTwo(int n){ //ç”¨ä½è¿ç®—æ¥åˆ¤æ–­æœ‰å‡ ä¸ª1ï¼Œè¦æ˜¯åªæœ‰ä¸€ä¸ª1é‚£å°±æ˜¯2çš„å¹‚ã€‚ if (n \u0026gt;= 2147483647 || n \u0026lt;= -2147483648) { return false; } int nu m =0; while (n\u0026gt;0 \u0026amp;\u0026amp; n!=0) { n \u0026amp;= (n-1); num++; } if (num!=1) { return false; } return true; } 234.å›æ–‡é“¾è¡¨ æ€è·¯ï¼› ä¸€ã€é€šè¿‡ä¸€ä¸ªæ•°ç»„è®°å½•é“¾è¡¨ä¸­çš„å…ƒç´ å€¼ï¼Œåœ¨åˆ¤æ–­æ•°ç»„æ˜¯å¦æ˜¯å›æ–‡ã€‚ äºŒã€ç¿»è½¬é“¾è¡¨ååŠéƒ¨åˆ†\n#define MAXSIZE 100000 bool isPalindrome(struct ListNode* head){ int size = 0; int nums[MAXSIZE] = {0}; struct ListNode* p = head; // åˆ¤æ–­æ¡ä»¶ while (p) { nums[size++] = p-\u0026gt;val; p = p-\u0026gt;next; } printf(\u0026#34;size = %d\\n\u0026#34;, size); int left = 0; int right = size - 1; while (left \u0026lt;= right) { if (nums[left] != nums[right]) { return false; } left++; right--; } return true; } struct ListNode *reverse(struct ListNode *head) { struct ListNode *res = NULL; while (head) { struct ListNode *pre_node = head; head = head-\u0026gt;next; pre_node-\u0026gt;next = res; res = pre_node; } return res; } bool isPalindrome(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; struct ListNode *last; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; faast = fast-\u0026gt;next-\u0026gt;next; } if (fast != NULL) { slow = slow-\u0026gt;next; } last = reverse(slow); while (last) { if (head-\u0026gt;val != last-\u0026gt;val) { return 0; } head = head-\u0026gt;next; last = last-\u0026gt;next; } return 1; } 242.æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯ æ€è·¯ï¼šå…ˆæ¯”è¾ƒé•¿åº¦ï¼Œä¸ç›¸ç­‰ falseï¼Œé€šè¿‡è¡¨æ ¼è®°å½•ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­å­—ç¬¦ï¼Œéå†ç¬¬äºŒä¸ªå­—ç¬¦ä¸²æ—¶è¡¨æ ¼è®°å½•\u0026ndash;ï¼Œæœ€åï¼Œåˆ¤æ–­è¡¨æ ¼ä¸­æ‰€æœ‰å€¼æ˜¯å¦ä¸ºé›¶\n#define NUMSIZE 256 bool isAnagram(char * s, char * t){ int sLen = strlen(s); int tLen = strlen(t); if (sLen != tLen) { return false; } int table[256] = {0}; for (int i = 0; i \u0026lt; sLen; i++) { table[s[i]]++; } for (int i = 0; i \u0026lt; tLen; i++) { table[t[i]]--; } for (int i = 0; i \u0026lt; NUMSIZE; i++) { if (table[i] != 0) { return false; } } return true; } 268.ä¸¢å¤±çš„æ•°å­— æ€è·¯ï¼šè¾¹æ±‚å’Œï¼Œè¾¹å‡å»æ•°ç»„ä¸­çš„æ•°å­—\nint missingNumber(int* nums, int numsSize){ int mNum = 0; for (int i = 0; i \u0026lt; numsSize; i++) { mNum += (i + 1); mNum -= nums[i]; } return mNum; } 278.ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬ æ€è·¯ï¼šäºŒåˆ†æŸ¥æ‰¾\nint firstBadVersion(int n) { int left = 1; int right = n; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (isBadVersion(mid) \u0026amp;\u0026amp; !isBadVersion(mid-1)) { return mid; } else if (isBadVersion(mid) \u0026amp;\u0026amp; isBadVersion(mid-1)) { right = mid - 1; } else { left = mid + 1; } } return -1; } int firstBadVersion(int n) { int low = 1, high = n; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (isBadVersion(mid)) { high = mid - 1; } else { low = mid + 1; } } return low; } 283.ç§»åŠ¨é›¶ æ€è·¯ï¼šä¸ç­‰äºé›¶æ—¶å‘æ•°ç»„ä¸­æ·»åŠ ï¼Œç­‰äºé›¶æ—¶è·³è¿‡ï¼Œæœ€åå¡«å……0 nums[start++] = nums[i]\nvoid moveZeroes(int* nums, int numsSize){ int start = 0; for (int i = 0; i \u0026lt; numsSize; i++) { if (nums[i] != 0) { nums[start++] = nums[i]; } } for (; start \u0026lt; numsSize; start++) { nums[start] = 0; } } 287.å¯»æ‰¾é‡å¤æ•´æ•° æ€è·¯ï¼šå¾ªç¯éå†ï¼Œæ ‡è®°ï¼Œåˆ¤æ–­æ˜¯å¦æ ‡è®°è¿‡ï¼Œreturn\n#define MAXSIZE 100001 int findDuplicate(int* nums, int numsSize){ int table[MAXSIZE] = {0}; for (int i = 0; i \u0026lt; numsSize; i++) { if (table[nums[i]] != 0) { return nums[i]; } else { table[nums[i]]++; } } return -1; } 344.åè½¬å­—ç¬¦ä¸² æ€è·¯ï¼šåŒæŒ‡é’ˆï¼Œäº¤æ¢\nvoid reverseString(char* s, int sSize){ int left =0; int right = sSize - 1; while (left \u0026lt; right) { char c = s[left]; s[left] = s[right]; s[right] = c; left++; right--; } } 367.æœ‰æ•ˆçš„å®Œå…¨å¹³æ–¹æ•° æ€è·¯ï¼šfor å¾ªç¯ï¼Œæ¡ä»¶ i * i \u0026lt;= num\nbool isPerfectSquare(int num) { for (long i = 0; i * i \u0026lt;= num; i++) { if (i * i == num) { return true; } } return false; } 387.å­—ç¬¦ä¸²ä¸­çš„ç¬¬ä¸€ä¸ªå”¯ä¸€å­—ç¬¦ æ€è·¯ï¼šä¸¤æ¬¡éå†ï¼Œç¬¬ä¸€æ¬¡éå†è§å­—æ¯æ ‡è®°å¾—åˆ°ç»Ÿè®¡è¡¨æ ¼ä¸­ï¼Œç¬¬äºŒæ¬¡éå†æ‰¾å‡ºç»Ÿè®¡è¡¨æ ¼ä¸­ç¬¬ä¸€ä¸ªä¸º1å­—ç¬¦ï¼Œè¿”å›å¯¹åº”ä¸‹æ ‡ã€‚\n#define NUMSIZE 256 int firstUniqChar(char * s){ int sLen = strlen(s); int table[NUMSIZE] = {0}; for (int i = 0; i \u0026lt; sLen; i++) { table[s[i]]++; } for (int i = 0; i \u0026lt; sLen; i++) { if (table[s[i]] == 1) { return i; } } return -1; } 389.æ‰¾ä¸åŒ æ€è·¯ï¼šå­—ç¬¦å¯ä»¥è½¬åŒ–ä¸ºæ•°å­—ï¼Œä¸ºäº†é˜²æ­¢æº¢å‡ºé€šè¿‡ - \u0026lsquo;a\u0026rsquo;ï¼Œæ±‚ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å·®å€¼ï¼Œåœ¨åŠ ä¸Š\u0026rsquo;a\u0026rsquo;\nchar findTheDifference(char * s, char * t){ int sLen = strlen(s); int tLen = strlen(t); int nS = 0; int nT = 0; for (int i = 0; i \u0026lt; sLen; i++) { nS += s[i] - \u0026#39;a\u0026#39;; } for (int i = 0; i \u0026lt; tLen; i++) { nT += t[i] - \u0026#39;a\u0026#39;; } return (char)(nT - nS + \u0026#39;a\u0026#39;); } 404.å·¦å¶å­ä¹‹å’Œ æ€è·¯ï¼šé€’å½’ï¼šåˆ¤æ–­å·¦å­æ ‘æ˜¯å¦ä¸ºå¶å­ç»“ç‚¹ï¼Œæ˜¯åˆ™è®°å½•sumï¼Œè¿”å› sum + é€’å½’è°ƒç”¨å·¦å­æ ‘ + é€’å½’è°ƒç”¨å³å­æ ‘\nint sumOfLeftLeaves(struct TreeNode* root){ if (root == NULL) { return 0; } int sum = 0; if (root-\u0026gt;left) { if (root-\u0026gt;left-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;left-\u0026gt;right == NULL) { sum += root-\u0026gt;left-\u0026gt;val; } } return sum + sumOfLeftLeaves(root-\u0026gt;left) + sumOfLeftLeaves(root-\u0026gt;right); } int isleaf(struct TreeNode* root) { return root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL; } int sumOfLeftLeaves(struct TreeNode* root) { if(root == NULL) { return 0; } if (root-\u0026gt;left) { if(isleaf(root-\u0026gt;left)) { // æ­¤å¤„ç›´æ¥é€’å½’ï¼Œå°‘ä¸€å±‚è°ƒç”¨ return root-\u0026gt;left-\u0026gt;val + sumOfLeftLeaves(root-\u0026gt;right); } } return sumOfLeftLeaves(root-\u0026gt;left) + sumOfLeftLeaves(root-\u0026gt;right); } 442.æ•°ç»„ä¸­é‡å¤çš„æ•°æ® æ€è·¯ï¼š ä¸€ã€é€šè¿‡è¡¨æ ‡è®°æ•°ç»„ä¸­å‡ºç°è¿‡çš„æ•°å­—ï¼Œå½“å†æ¬¡å‡ºç°æ—¶å°†æ•°å­—æ·»åŠ åˆ°è¿”å›æ•°ç»„ä¸­ã€‚ äºŒã€\n#define MAXSIZE 100000 int* findDuplicates(int* nums, int numsSize, int* returnSize){ int table[MAXSIZE] = {0}; *returnSize = 0; int *res = (int *)malloc(sizeof(int) * MAXSIZE); for (int i = 0; i \u0026lt; numsSize; i++) { if (table[nums[i]] == 1) { res[*returnSize] = nums[i]; (*returnSize)++; } else { table[nums[i]]++; } } return res; } int* findDuplicates(int* nums, int numsSize, int* returnSize) { int table[100000] = {0}; int *res = (int *)malloc(sizeof(int) * 100000); int j = 0; for (int i = 0; i \u0026lt; numsSize; i++) { table[nums[i]]++; if (table[nums[i]] == 2) { res[j++] = nums[i]; } } *returnSize = j; return res; } 461.æ±‰æ˜è·ç¦» æ€è·¯ï¼š ä¸€ã€æ±‚ x ^ y ä¸­ 1 çš„ä¸ªæ•° äºŒã€æ¯”è¾ƒxï¼Œyçš„æ¯ä¸€ä½ å’Œ 1ä¸\nint hammingDistance(int x, int y) { int n = x ^ y; int res = 0; while (n) { int p = n \u0026amp; 1; if (p) { res++; } n \u0026gt;\u0026gt;= 1; } return res; } int hammingDistance(int x, int y){ int count = 0; while (x || y) { int nX = x \u0026amp; 0x1; int nY = y \u0026amp; 0x1; if (nX != nY) { count++; } x \u0026gt;\u0026gt;= 1; y \u0026gt;\u0026gt;= 1; } return count; } 476.æ•°å­—çš„è¡¥æ•° æ€è·¯ï¼š ä¸€ã€æŒ‰ä½ä¸1æ±‚ä¸ï¼Œå†å–å(!)ï¼Œç„¶åç§»ä½ï¼Œ äºŒã€å…ˆç»Ÿè®¡ä½æ•°ï¼Œåœ¨å–ä½æ•°ç›¸åŒå…¨ä¸€æ•°ï¼Œæœ€åä¸åŸæ•°å­—æ±‚å¼‚æˆ– ^\nint findComplement(int num){ int res = 0; int count = 0; while (num) { int t = !(num \u0026amp; 0x1); t \u0026lt;\u0026lt;= count; printf(\u0026#34;t = %d\\n\u0026#34;, t); res += t; count++; num\u0026gt;\u0026gt;=1; } return res; } int findComplement(int num){ int totalBits = 0; int tmp = num; while (tmp) { totalBits++; tmp \u0026gt;\u0026gt;= 1; } int flipNumber = 1; for (int i = 1; i \u0026lt; totalBits; i++) { flipNumber += UINT32_C(1) \u0026lt;\u0026lt; i; } num = num ^ flipNumber; return num; } 509.æ–æ³¢é‚£å¥‘æ•°åˆ— æ€è·¯ï¼šä¸€ã€é€’å½’ äºŒã€è¿­ä»£\né€’å½’ int fib(int n){ if (n \u0026lt;= 1) { return n; } return fib(n - 1) + fib(n - 2); } è¿­ä»£ int fib(int n){ if (n \u0026lt;= 1) { return n; } int* nums = (int *)malloc(sizeof(int) * (n + 1)); nums[0] = 0; nums[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { nums[i] = nums[i - 1] + nums[i - 2]; } return nums[n]; } 520.æ£€æµ‹å¤§å†™å­—æ¯ æ€è·¯ï¼š ä¸€ã€å…ˆåˆ¤æ–­ç¬¬äºŒä¸ªå­—æ¯æ˜¯å¦ä¸ºå¤§å†™ï¼Œ1.word[1] å¤§å†™ï¼Œä»ä»é›¶å¼€å§‹åˆ¤æ–­æ˜¯å¦å…¨ä¸ºå¤§å†™ 2.word[1]ä¸ºå°å†™ï¼Œä»wordæ˜¯å¦å…¨ä¸ºå°å†™ã€‚ äºŒã€\nbool detectCapitalUse(char * word){ int len = strlen(word); if (len \u0026lt;= 1) { return true; } int i = 1; if (isupper(word[i])) { i = 0; while (word[i] != \u0026#39;\\0\u0026#39;) { if (!isupper(word[i])) { return false; } i++; } } else { while (word[i] != \u0026#39;\\0\u0026#39;) { if (isupper(word[i])) { return false; } i++; } } return true; } bool detectCapitalUse(char * word){ int len = strlen(word); if (len == 1) { return true; } for (int i = 1; i \u0026lt; len; i++) { // word[0] æ¯æ¬¡éƒ½éœ€è¦åˆ¤æ–­ï¼Œä¸€ä¸ªå¤æ‚åº¦ã€‚ if (isupper(word[0]) \u0026amp;\u0026amp; isupper(word[1])) { if (!isupper(word[i])) { return false; } } else { if (isupper(word[i])) { return false; } } } return true; } 561.æ‹†åˆ†æ•°ç»„I æ€è·¯ï¼šæ’åºï¼Œå–å¶æ•°ä½æ±‚å’Œã€‚\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } int arrayPairSum(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), Cmp); int minSum = 0; for (int i = 0; i \u0026lt; numsSize; i++) { if (i % 2 == 0) { minSum += nums[i]; } } return minSum; } 617.åˆå¹¶äºŒå‰æ ‘ æ€è·¯ï¼šé€’å½’ï¼Œåˆ¤ç©ºï¼Œ\nstruct TreeNode* newNode(int val) { struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-\u0026gt;val = val; node-\u0026gt;left = NULL; node-\u0026gt;right = NULL; return node; } struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){ /* if (root1 == NULL \u0026amp;\u0026amp; root2 == NULL) { return NULL; } */ if (root1 == NULL) { return root2; } if (root2 == NULL) { return root1; } /* struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root-\u0026gt;val += root1 == NULL ? 0 : root1-\u0026gt;val; root-\u0026gt;val += root2 == NULL ? 0 : root2-\u0026gt;val; root-\u0026gt;left = NULL; root-\u0026gt;right = NULL; */ int val = (root1 == NULL ? 0 : root1-\u0026gt;val) + (root2 == NULL ? 0 : root2-\u0026gt;val); struct TreeNode* root = newNode(val); root-\u0026gt;left = mergeTrees(root1-\u0026gt;left, root2-\u0026gt;left); root-\u0026gt;right = mergeTrees(root1-\u0026gt;right, root2-\u0026gt;right); return root; } 647.å›æ–‡å­ä¸² æ€è·¯ï¼šå·¦ä¾§åˆ¤æ–­å»é‡ï¼Œå·¦å³åˆ¤æ–­ç›¸ç­‰ã€‚\nint countSubstrings(char * s) { int len = strlen(s); int res = len; // æ¯ä¸ªå­—ç¬¦éƒ½æ˜¯å›æ–‡ for (int i = 0; i \u0026lt; len; i++) { int p = i - 1; while (p \u0026gt;= 0 \u0026amp;\u0026amp; s[p] == s[i]) { // å·¦ä¾§å»é‡ res++; p--; } int q = i + 1; while (p \u0026gt;= 0 \u0026amp;\u0026amp; q \u0026lt; len \u0026amp;\u0026amp; s[p] == s[q]) { // åˆ¤æ–­å·¦å³ç›¸ç­‰ res++; p--; q++; } } return res; } int countSubstrings(char * s){ int len = strlen(s); int count = 0; for (int i = 0; i \u0026lt; len; i++) { count += countPalin(s, i, i, len); if (i != len - 1) { count += countPalin(s, i, i+1, len); } } return count; } int countPalin(char *s, int head, int tail, int len) { int ret = (s[head] == s[tail]) ? 1 : 0; if (ret \u0026amp;\u0026amp; head - 1 \u0026gt;= 0 \u0026amp;\u0026amp; tail + 1 \u0026lt; len) { ret += countPalin(s, head - 1, tail + 1, len); } return ret; } 674.æœ€é•¿è¿ç»­é€’å¢åºåˆ— æ€è·¯ï¼šåŒå¾ªç¯åˆ¤æ–­ï¼Œ\nint findLengthOfLCIS(int* nums, int numsSize){ if (numsSize == 1) { return 1; } int p2 = 0; int res = 0; for (int i = 1; i \u0026lt; numsSize; i++) { while (i \u0026lt; numsSize \u0026amp;\u0026amp; nums[i-1] \u0026lt; nums[i]) { i++; } res = res \u0026gt; i - p2 ? res : i - p2; p2 = i; } return res; } int findLengthOfLCIS(int* nums, int numsSize){ int maxLen = 0; int i = 0; while (i \u0026lt; numsSize) { int start = i; while (start + 1 \u0026lt; numsSize \u0026amp;\u0026amp; nums[start] \u0026lt; nums[start + 1]) { start++; } maxLen = maxLen \u0026gt; (start - i + 1) ? maxLen : (start - i + 1); start++; i = start; } return maxLen; } 700.äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢ æ€è·¯ï¼šé€’å½’ï¼Œæ³¨æ„ åˆ¤ç©º root == NULL\nstruct TreeNode* searchBST(struct TreeNode* root, int val){ if (root == NULL) { return NULL; } if (root-\u0026gt;val == val) { return root; } else if (root-\u0026gt;val \u0026gt; val) { return searchBST(root-\u0026gt;left, val); } else { return searchBST(root-\u0026gt;right, val); } return NULL; } 701.äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ æ€è·¯ï¼šé€’å½’ï¼Œé€’å½’å‡ºå£ï¼Œroot == NULL, æ–°å»ºæ ‘ç»“ç‚¹ malloc\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){ if (root == NULL) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode-\u0026gt;val = val; newNode-\u0026gt;left = NULL; newNode-\u0026gt;right = NULL; return newNode; } if (root-\u0026gt;val \u0026lt; val) { root-\u0026gt;right = insertIntoBST(root-\u0026gt;right, val); } if (root-\u0026gt;val \u0026gt; val) { root-\u0026gt;left = insertIntoBST(root-\u0026gt;left, val); } return root; } 704.äºŒåˆ†æŸ¥æ‰¾ æ€è·¯ï¼šäºŒåˆ†æŸ¥æ‰¾ï¼Œæ³¨æ„ left \u0026lt;= right ï¼ŒåŒ…å«ç­‰äº\nint search(int* nums, int numsSize, int target){ int left = 0; int right = numsSize - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else { left = mid + 1; } } return -1; } 709.è½¬æ¢æˆå°å†™å­—æ¯ æ€è·¯ï¼›åº“å‡½æ•° isupper, tolower\nchar * toLowerCase(char * s){ int len = strlen(s); for (int i = 0; i \u0026lt; len; i++) { if (isupper(s[i])) { s[i] = tolower(s[i]); } } return s; } 771.å®çŸ³å’ŒçŸ³å¤´ æ€è·¯ï¼šè¡¨è®°å½•stonesä¸­æ¯ä¸ªå­—ç¬¦ä¸ªæ•°ï¼Œæ±‚å’Œjewelså­—ç¬¦è¡¨ä¸­çš„å€¼\nint numJewelsInStones(char * jewels, char * stones){ int table[256] = {0}; int sLen = strlen(stones); for (int i = 0; i \u0026lt; sLen; i++) { table[stones[i]]++; } int jLen = strlen(jewels); int sum = 0; for (int i = 0; i \u0026lt; jLen; i++) { sum += table[jewels[i]]; } return sum; } 852.å±±è„‰æ•°ç»„çš„å³°é¡¶ç´¢å¼• æ€è·¯ï¼šåˆ¤æ–­æ¡ä»¶ï¼Œå®Œå…¨\nint peakIndexInMountainArray(int* arr, int arrSize){ int low = 1, high = arrSize; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (arr[mid - 1] \u0026lt; arr[mid] \u0026amp;\u0026amp; arr[mid] \u0026gt; arr[mid + 1]) return mid; else if (arr[mid - 1] \u0026lt; arr[mid] \u0026amp;\u0026amp; arr[mid] \u0026lt; arr[mid + 1]) low = mid + 1; else high = mid - 1; } return -1; } 876.é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ æ€è·¯ï¼šå¿«æ…¢æŒ‡é’ˆï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆé€šè¿‡ å¶æ•°åˆ¤æ–­ forå¾ªç¯\nstruct ListNode* middleNode(struct ListNode* head){ struct ListNode* pos1 = head; struct ListNode* pos2 = head; for (int i = 0; pos1-\u0026gt;next != NULL; pos1 = pos1-\u0026gt;next, i++) { if (i % 2 == 0) { pos2 = pos2-\u0026gt;next; } } return pos2; } 905.æŒ‰å¥‡å¶æ’åºæ•°ç»„ æ€è·¯: ä¸€ã€åŒæŒ‡é’ˆï¼ŒåŒ917 äºŒã€åˆ¤æ–­ï¼Œå‰åç´¢å¼•ç§»åŠ¨ï¼ŒåŒæŒ‡é’ˆ\nè§£æ³•ä¸€ï¼š int* sortArrayByParity(int* nums, int numsSize, int* returnSize) { *returnSize = numsSize; int start = 0; int end = numsSize - 1; while (start \u0026lt; end) { while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] % 2 == 0) { start++; } while (end \u0026gt; start \u0026amp;\u0026amp; nums[end] % 2 == 1) { end--; } while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] % 2 != 0 \u0026amp;\u0026amp; nums[end] % 2 != 1) { int tmp = nums[start]; nums[start] = nums[end]; nums[end] = tmp; start++; end--; } } return nums; } int* sortArrayByParity(int* nums, int numsSize, int* returnSize){ *returnSize = numsSize; int left = 0; int right = numsSize - 1; while (left \u0026lt; right) { if (nums[left] % 2 == 0) { left++; continue; } if (nums[right] % 2 == 1) { right--; continue; } int tmp = nums[left]; nums[left] = nums[right]; nums[right] = tmp; left++; right--; } return nums; } è§£æ³•äºŒï¼› int* sortArrayByParity(int* nums, int numsSize, int* returnSize){ int *res = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; int j = 0; int p = numsSize - 1; for (int i = 0; i \u0026lt; numsSize; i++) { if (nums[i] % 2 == 0) { res[j] = nums[i]; j++; } else { res[p] = nums[i]; p--; } } return res; } 917.ä»…ä»…åè½¬å­—æ¯ æ€è·¯ï¼šåŒæŒ‡é’ˆï¼Œåº“å‡½æ•° isalphaï¼Œ continue\nchar * reverseOnlyLetters(char * s){ int len = strlen(s); int left = 0; int right = len - 1; while (left \u0026lt; right) { if (!isalpha(s[left])) { left++; continue; } if (!isalpha(s[right])) { right--; continue; } //if (isalpha(s[left]) \u0026amp;\u0026amp; isalpha(s[right])) { char c = s[left]; s[left] = s[right]; s[right] = c; left++; right--; //} } return s; } 938.äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œ int rangeSumBST(struct TreeNode* root, int low, int high){ if (root == NULL) { return 0; } if (low \u0026gt; root-\u0026gt;val) { return rangeSumBST(root-\u0026gt;right, low, high); } if (high \u0026lt; root-\u0026gt;val) { return rangeSumBST(root-\u0026gt;left, low, high); } return root-\u0026gt;val + rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } int rangeSumBST(struct TreeNode* root, int low, int high){ if (root == NULL) { return 0; } else if (root-\u0026gt;val \u0026gt;= low \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= high) { return root-\u0026gt;val + rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } else { return rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } } 965.å•å€¼äºŒå‰æ ‘ æ€è·¯ï¼šé€’å½’ï¼Œé€’å½’å‡ºå£ï¼šroot == NULL\nbool isUnivalTree(struct TreeNode* root){ // rootä¸åˆ¤ç©ºä¼šæŠ¥é”™ï¼š // member access within null pointer of type \u0026#39;struct TreeNode\u0026#39; if (root == NULL) { return true; } // å¤šä½™ /* if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { return true; } */ if (root-\u0026gt;left != NULL) { if (root-\u0026gt;left-\u0026gt;val != root-\u0026gt;val) { return false; } } if (root-\u0026gt;right != NULL) { if (root-\u0026gt;right-\u0026gt;val != root-\u0026gt;val) { return false; } } return isUnivalTree(root-\u0026gt;left) \u0026amp;\u0026amp; isUnivalTree(root-\u0026gt;right); } 977.æœ‰åºæ•°ç»„çš„å¹³æ–¹ æ€è·¯: ä¸€ã€å…ˆå¹³æ–¹ï¼Œå†æ’åº äºŒã€åŒæŒ‡é’ˆï¼Œå·¦å³æŒ‡é’ˆæ¯”è¾ƒç»å¯¹å€¼å¤§å°ï¼Œä»åå‘å‰å¡«å……ç»“æœæ•°ç»„\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } int* sortedSquares(int* nums, int numsSize, int* returnSize){ int* squareNum = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; for (int i = 0; i \u0026lt; numsSize; i++) { //squareNum[i] = nums[i] * nums[i]; squareNum[i] = pow(nums[i], 2); } qsort(squareNum, numsSize, sizeof(int), Cmp); return squareNum; } int* sortedSquares(int* nums, int numsSize, int* returnSize){ int* squareNum = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; int left = 0; int right = numsSize - 1; int i = numsSize - 1; while (left \u0026lt; right) { if (fabs(nums[left]) \u0026gt; nums[right]) { squareNum[i--] = nums[left] * nums[left]; left++; } else { squareNum[i--] = nums[right] * nums[right]; right--; } } squareNum[i] = nums[left] * nums[left]; return squareNum; } 1089.å¤å†™é›¶ æ€è·¯ï¼šå°†åŸæ•°ç»„å¤åˆ¶ä¸€ä»½ï¼Œæ ¹æ®å¤åˆ¶æ•°ç»„ï¼Œä¿®æ”¹åŸæ•°ç»„å€¼\nvoid duplicateZeros(int* arr, int arrSize) { int b[arrSize]; // = {0}; memcpy(b, arr, sizeof(int) * arrSize); for (int i = 0, j = 0; i \u0026lt; arrSize \u0026amp;\u0026amp; j \u0026lt; arrSize; i++) { arr[j++] = b[i]; if (j \u0026lt; arrSize \u0026amp;\u0026amp; b[i] == 0) { arr[j++] = 0; } }W } void duplicateZeros(int* arr, int arrSize){ int * nums = (int *)malloc(sizeof(int) * arrSize); for (int i = 0; i \u0026lt; arrSize; i++) { nums[i] = arr[i]; } int j = 0; for (int i = 0; i \u0026lt; arrSize; i++, j++) { arr[i] = nums[j]; if (i + 1 \u0026lt; arrSize \u0026amp;\u0026amp; nums[j] == 0) { arr[++i] = 0; } } } 1184.å…¬äº¤ç«™é—´çš„è·ç¦» æ€è·¯: ä¿è¯ start å°äº destinationï¼Œ è®¡ç®—ä¸€åœˆçš„æ€»é•¿åº¦sumï¼Œè®¡ç®—startåˆ°destinationçš„è·ç¦»dï¼Œå–dä¸sum-dä¸¤è€…è¾ƒå°å€¼\nint distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){ if (start \u0026gt; destination) { int tmp = start; start = destination; destination = tmp; } int min = 0; int sum = 0; for (int i = 0; i \u0026lt; distanceSize; i++) { sum += distance[i]; if (i \u0026gt;= start \u0026amp;\u0026amp; i \u0026lt; destination) { min += distance[i]; } } min = min \u0026lt; (sum - min) ? min : sum - min; return min; } 1189. â€œæ°”çƒâ€ çš„æœ€å¤§æ•°é‡ æ€è·¯ï¼šç»Ÿè®¡å­—ç¬¦æ¬¡æ•°ï¼Œæ³¨æ„ å­—ç¬¦ä¸²æŒ‡é’ˆ å–å€¼ *p æˆ–è€… å­—ç¬¦æ•°ç»„ test[i]\nint maxNumberOfBalloons(char * text){ int len = strlen(text); int table[5] = {0}; char* p = text; while (*p != \u0026#39;\\0\u0026#39;) { if (*p == \u0026#39;b\u0026#39;) { table[0]++; } if (*p == \u0026#39;a\u0026#39;) { table[1]++; } if (*p == \u0026#39;l\u0026#39;) { table[2]++; } if (*p == \u0026#39;o\u0026#39;) { table[3]++; } if (*p == \u0026#39;n\u0026#39;) { table[4]++; } p++; } table[2] /= 2; table[3] /= 2; int min = INT_MAX; for (int i = 0; i \u0026lt; 5; i++) { min = min \u0026lt; table[i] ? min : table[i]; } return min; } /* int maxNumberOfBalloons(char * text){ int len = strlen(text); int testNum[5] = {0}; for (int i = 0; i \u0026lt; len; i++) { if (text[i] == \u0026#39;b\u0026#39;) { testNum[0]++; } if (text[i] == \u0026#39;a\u0026#39;) { testNum[1]++; } if (text[i] == \u0026#39;l\u0026#39;) { testNum[2]++; } if (text[i] == \u0026#39;o\u0026#39;) { testNum[3]++; } if (text[i] == \u0026#39;n\u0026#39;) { testNum[4]++; } } testNum[2] /= 2; testNum[3] /= 2; int res = INT_MAX; for (int i = 0; i \u0026lt; 5; i++) { res = res \u0026lt; testNum[i] ? res : testNum[i]; } return res; } */ 1207.ç‹¬ä¸€æ— äºŒçš„å‡ºç°æ¬¡æ•° è§£æ³•ä¸€\né€šè¿‡ä¸€ä¸ªè¡¨ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°ï¼Œå®šä¹‰å¦å¤–ä¸€ä¸ªè¡¨è®°å½•è¡¨ä¸€ä¸­æ¯ä¸€é¡¹çš„ï¼Œå¦‚æœå‡ºç°ç›¸åŒæ•°å­—ï¼Œåˆ™è¿”å›falseï¼Œéå†åˆ°æœ€åæ—¶è¿”å›true\nuniqueOccurrences bool uniqueOccurrences(int* arr, int arrSize){ int table[2001] = {0}; for (int i = 0; i \u0026lt; arrSize; i++) { table[arr[i] + 1000]++; printf(\u0026#34;table[arr[%d] + 1000] = %d\\n\u0026#34;, i, table[arr[i] + 1000]); } int table1[2001] = {0}; for (int i = 0; i \u0026lt; 2001; i++) { table1[i] = 0; if (table[i] != 0) { if (table1[table[i]] != 0) { printf(\u0026#34;table1[table[%d]] = %d\\n\u0026#34;, i, table1[table[i]]); return false; } else { table1[table[i]]++; } } } return true; } è§£æ³•äºŒï¼š\nåŒè§£æ³•ä¸€\n/* */ bool uniqueOccurrences(int* arr, int arrSize){ int hashTable[2001]={0};//åˆå§‹åŒ–ä¸€å¼ è¡¨ï¼Œä¸‹æ ‡å¯¹åº”å…ƒç´ å€¼ï¼Œå­˜å‚¨å¯¹åº”å…ƒç´ å‡ºç°çš„æ¬¡æ•° for(int i=0;i\u0026lt;arrSize;i++) { hashTable[arr[i]+1000]++; } bool visited[1001]={false}; for(int i=0;i\u0026lt;2001;i++) { if(hashTable[i]) { //å¦‚æœiåœ¨æ•°ç»„ä¸­ if(visited[hashTable[i]]) { //å¦‚æœä¹‹å‰å‡ºç°è¿‡ä¸iç›¸åŒçš„é‡å¤æ¬¡æ•° return false; } else { visited[hashTable[i]]=true;//è¯´æ˜ä¸iç›¸åŒçš„é‡å¤æ¬¡æ•°è¿˜æœªå‡ºç°ï¼Œè®¾ç½®ä¸ºå·²è®¿é—®è¿‡ } } } return true; } å‚è€ƒåšå®¢ï¼š https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/leetcode%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/","summary":"æ€»ç»“ leetcodeåŸºç¡€é¢˜ç›® ç»å…¸é¢˜ç›®ï¼š 3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² 4. 6. 7. 8. 9. 11. 12. 13. 21. 24. 28. 38. 53. 66. 82. 94. 104. 108. 109. 110. 112. 121. 136. 142. 160. 169. 173. 189. 201. 203. 206. 217. 226. 231. 234. 367. 389. 442. 476.","title":"leetcodeåŸºç¡€é¢˜ç›®"},{"content":"Linux Kernelé˜…è¯»å·¥å…· éœ€è¦å¤šä¹…æ‰èƒ½çœ‹å®Œlinuxå†…æ ¸æºç ï¼Ÿ\nLinuxå†…æ ¸ä»£ç ä¸‹è½½ Linux kernelå®˜ç½‘ https://www.kernel.org/\nè§£å‹ linux-5.19.10.tar.xz\ntar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035\ngdb ã€Š100ä¸ªgdbå°æŠ€å·§ã€‹\nkbuild Kbuild: the Linux Kernel Build System Kernel Build SystemÂ¶\nhttps://www.zhihu.com/question/47039391/answer/2287806626\nELF å¼€æºåº“ lief\nå‚è€ƒé“¾æ¥ï¼š https://blog.csdn.net/GrayOnDream/article/details/124564129\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linuxreadtool/","summary":"Linux Kernelé˜…è¯»å·¥å…· éœ€è¦å¤šä¹…æ‰èƒ½çœ‹å®Œlinuxå†…æ ¸æºç ï¼Ÿ Linuxå†…æ ¸ä»£ç ä¸‹è½½ Linux kernelå®˜ç½‘ https://www.kernel.org/ è§£å‹ linux-5.19.10.tar.xz tar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035 gdb ã€Š100ä¸ªgdbå°æŠ€å·§ã€‹","title":"Linux Read Tool"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/tech/tech/","summary":"","title":"Tech"},{"content":"\rZain\u0026#39;s Blog\rä¸€ä¸ªè®°å½•æŠ€æœ¯ã€é˜…æ–‡ã€ç”Ÿæ´»çš„åšå®¢\rğŸ‘‰ è¶Šè¿‡é•¿åŸï¼Œèµ°å‘ä¸–ç•Œ Across the Great Wall we can reach every corner in the world \u0026ndash; 1987.09.14 Chromego\n","permalink":"https://liuz0123.gitee.io/zain/links/","summary":"Zain\u0026#39;s Blog ä¸€ä¸ªè®°å½•æŠ€æœ¯ã€é˜…æ–‡ã€ç”Ÿæ´»çš„åšå®¢ ğŸ‘‰ è¶Šè¿‡é•¿åŸï¼Œèµ°å‘ä¸–ç•Œ Across the Great Wall we can reach every corner in the world \u0026ndash; 1987.09.14 Chromego","title":"ğŸ¤é—²è¨€ä¿—è¯­"},{"content":"\nè‹±æ–‡å: zain Lz èŒä¸š: ç¨‹åºå‘˜ è¿åŠ¨: è·‘æ­¥ã€ç¯®çƒã€çˆ¬å±± ç½‘å€ï¼š https://liuz0123.gitee.io/zain å›¾æ ‡ï¼š https://liuz0123.gitee.io/zain/img/Q.gif æè¿°ï¼š ä¸€ä¸ªè®°å½•æŠ€æœ¯ã€é˜…è¯»ã€ç”Ÿæ´»è‡ªç”¨åšå®¢, hexo To hugo è¿ç§»ä¸­ æ€è€ƒã€è§‰æ‚Ÿã€æˆé•¿ã€æ²‰é™ï¼Œæ—¶è€Œé€—æ¯”ï¼Œæ—¶è€Œå®‰é™ï¼Œæ˜å¿ƒè§æ€§ ğŸ‘‰Hugoåšå®¢äº¤æµç¾¤\r787018782\n","permalink":"https://liuz0123.gitee.io/zain/about/","summary":"è‹±æ–‡å: zain Lz èŒä¸š: ç¨‹åºå‘˜ è¿åŠ¨: è·‘æ­¥ã€ç¯®çƒã€çˆ¬å±± ç½‘å€ï¼š https://liuz0123.gitee.io/zain å›¾æ ‡ï¼š https://liuz0123.gitee.io/zain/img/Q.gif æè¿°ï¼š ä¸€ä¸ªè®°å½•æŠ€æœ¯ã€é˜…è¯»ã€ç”Ÿæ´»è‡ªç”¨åšå®¢, hexo To hugo è¿ç§»ä¸­ æ€è€ƒã€è§‰æ‚Ÿã€æˆé•¿ã€æ²‰é™ï¼Œæ—¶","title":"ğŸ™‹ğŸ»â€â™‚ï¸å…³äº"}]